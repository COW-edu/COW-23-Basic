# 렛츠기릿 자바스크립트

## cow 주차별 학습 5주차

### 계산기 순서도 그리기

- 단계적으로 더 구체화시키는 것이 중요
<img width="267" alt="스크린샷 2023-04-10 오후 8 07 05" src="https://user-images.githubusercontent.com/96857599/230890415-d2ca4fe3-374e-4ed7-85d6-55e136ba62ae.png">

<img width="383" alt="스크린샷 2023-04-10 오후 8 07 32" src="https://user-images.githubusercontent.com/96857599/230890498-a4c424de-e16c-4bc4-8a9a-96b4c8e02769.png">

<img width="845" alt="스크린샷 2023-04-10 오후 8 09 15" src="https://user-images.githubusercontent.com/96857599/230890705-27e55594-05b8-4ace-bee7-6a4dd2d32d6b.png">

**계산기 기본 틀**
```html
<input readonly id="operator">
```
- 위 코드에서 readonly는 클라이언트가 html 상에 input을 하지 못하게 하기 위함이다.
- 우리는 js로 입력값을 받을 것이다.
<img width="1168" alt="스크린샷 2023-04-10 오후 8 18 38" src="https://user-images.githubusercontent.com/96857599/230891858-61a5cf41-62f2-4f87-8a45-191956d05f80.png">

### 함수 중복 제거하기(고차함수(high order fuction))
<img width="501" alt="스크린샷 2023-04-10 오후 8 35 49" src="https://user-images.githubusercontent.com/96857599/230894230-d925ea75-3a19-4931-bdf1-427fa5addf28.png">
- 위 코드처럼 아래의 코드를 중복해서 0~9까지 모두 작성해야한다. 중복은 싫다.

```js
document.querySelector('#num-0').addEventListener ('click', () => {
    if (operator) {
        numTwo += '0';
    } 
    else {
        numOne += '0';
    }
    $result.value += '0'
}); 
```
- 중복 제거를 위한 함수 생성

```javaScript
const onClickNumber = (number) => {
    if (operator) {
        numTwo += number;
    } 
    else {
        numOne += number;
    }
    $result.value += number;
};

document.querySelector('#num-0').addEventListener ('click', onClickNumber(1)); 
```

위와 같이 코드를 실행하면 onClickNumber(1)는 함수를 실행시킨 것이므로, onClickNumber의 return 값인 undefined가 출력된다. 

이를 해결하려면, 실행된 함수의 return 값에 실행될 함수를 넣으면 된다. 

```javaScript
const onClickNumber = (number) => {
  return () => {
      if (operator) {
      numTwo += number;
  } 
  else {
      numOne += number;
  }
  $result.value += number;
  }

};
```

이때, 중괄호와 return이 붙으면 생략할 수 있으므로,

```javaScript
 const onClickNumber = (number) => () => {
    if (operator) {
        numTwo += number;
    } 
    else {
        numOne += number;
    }
    $result.value += number;
};
```

**이렇게 함수가 함수를 return하는 함수를 고차함수(high order fuction)라고 한다.**

- 고차함수로 중복 제거한 전체 코드 

<img width="1056" alt="스크린샷 2023-04-10 오후 9 07 46" src="https://user-images.githubusercontent.com/96857599/230898785-c6637eed-5041-4337-bda4-943d399796b6.png">

- 고차함수 이해하기 쉬운 코드
<img width="277" alt="스크린샷 2023-04-10 오후 9 04 32" src="https://user-images.githubusercontent.com/96857599/230898334-61b8a0c6-b4b1-4d86-a540-6ff80bb240aa.png">

### event 객체로 중복 제거하기

#### event

```javaScript
const a = (event) => { console.log(event.target.value) };
document.querySelector('#num-0').addEventListener ('click', a); 
```
다음과 같은 코드가 있을 때, 

document.querySelector('#num-0').addEventListener ('click', a); 

브라우저는 'click'할 때, 위 코드에서 a를 실행시킬 때 a();의 인수로 event 객체를 넣어준다.

이 때의 인수를 a = (event) => { console.log(event.target.value }; 에서 매개번수로 적은 것이다.

이를 이용해 중복 제거.

```javaScript
const onClickNumber = (event) => {
    if (operator) {
        numTwo += event.target.textContent;
    } 
    else {
        numOne += event.target.textContent;
    }
    $result.value += event.target.textContent;
};

document.querySelector('#num-0').addEventListener('click', onClickNumber); 
```

<img width="1056" alt="스크린샷 2023-04-10 오후 9 10 56" src="https://user-images.githubusercontent.com/96857599/230899229-f450926b-88c2-47a4-a95c-38f913b0d7c3.png">

- onClickOperator는 고차 함수로 중복을 제거한 함수를 만들어준다.
```javaScript
const onClickOperator = (op) => () => {
    if (numOne) {
        operator = op;
        $operator.value = op;
    }
    else {
        alert('숫자를 먼저 입력하세요.')
    }
}

document.querySelector('#plus').addEventListener('click', onClickOperator('+'));
document.querySelector('#minus').addEventListener('click', onClickOperator("-"));
document.querySelector('#divide').addEventListener('click', onClickOperator("/")); 
document.querySelector('#multiply').addEventListener('click', onClickOperator("*"));
```

- 여기까지하면 3 + 4가 34인 기묘한 일이 일어난다.

<img width="847" alt="스크린샷 2023-04-10 오후 9 31 24" src="https://user-images.githubusercontent.com/96857599/230901949-85550695-6574-4ed1-9ac6-154431726188.png">

- 수정 코드를 넣어준다.

```javaScript
const onClickNumber = (event) => {
    if (operator) {
        // 2번째 숫자가 들어오기 전에 빈 화면으로 바꿔줌
        if (!numTwo) {
            $result.value = '';
        }
        numTwo += event.target.textContent;
    } 
    else {
        numOne += event.target.textContent;
    }
    $result.value += event.target.textContent;
};
```


### if문 중첩 줄이기

- 기존 코드
<img width="362" alt="스크린샷 2023-04-11 오전 12 10 48" src="https://user-images.githubusercontent.com/96857599/230929636-809436e7-cefe-47c0-ae86-18349999de0c.png">

- 중첩 제거법

1. if문 다음에 나오는 공통된 절차를 각 분기점 내부에 넣는다. 
<img width="387" alt="스크린샷 2023-04-11 오전 12 11 19" src="https://user-images.githubusercontent.com/96857599/230929749-7ef1800f-bc4e-4cb6-8e14-5988e3ed369a.png">

2. 분기점에서 짧은 절차부터 실행하게 if 문을 작성한다.
<img width="393" alt="스크린샷 2023-04-11 오전 12 12 11" src="https://user-images.githubusercontent.com/96857599/230929910-8c1599c5-bf67-432f-b7b9-1af55a442908.png">

3. 짧은 절차가 끝나면 return(함수 내부의 경우)이나 break(for 문 내부의 경우)로 중단한다.
4. else 를 제거한다(이때 중첩 하나가 제거된다).
<img width="388" alt="스크린샷 2023-04-11 오전 12 13 15" src="https://user-images.githubusercontent.com/96857599/230930128-5dc40069-c9d4-4fb4-8e57-96fb6ebae5b2.png">


### 결과 계산하기, 초기화

> eval: 문자로 표현 된 JavaScript 코드를 실행하는 함수
> 

> '3+4'라는 문자열을 js가 자동으로 3+4로 인식해서 계산하게 할 수는 없을까? 
> -> 과거에는 eval('3+4')로 가능했다. 이제는 보안상의 문제(사용자가 입력창에서 js를 조작할 수 있기 때문)로 불가능.



- 계산하기

```javaScript
const onClickCalculate = () => {
    if (numTwo) {
        switch (operator) {
            case "+" :
                $result.value = parseInt(numOne) + parseInt(numTwo);
                break;
            case "-" :
                $result.value = numOne - numTwo;
                break;
            case "*" :
                $result.value = numOne * numTwo;
                break;
            case "/" :
                $result.value = numOne / numTwo;
                break; 
            default:
                break;   
        }
    }
    else {
        alert("숫자를 먼저 입력하세요.")
    }

}

document.querySelector('#calculate').addEventListener('click', onClickCalculate);
```

- 초기화 하기

```javaScript
const onClickClear = () => {
    numOne = '';
    operator = '';
    numTwo = '';
    $operator.value = '';
    $result.value = '';
}

document.querySelector('#clear').addEventListener('click', onClickClear);
```

### 연달아 계산하기(= 이후 추가 계산)

```javaScript
const onClickCalculate = () => {
    if (numTwo) {
        switch (operator) {
            case "+" :
                $result.value = parseInt(numOne) + parseInt(numTwo);
                break;
            case "-" :
                $result.value = numOne - numTwo;
                break;
            case "*" :
                $result.value =numOne * numTwo;
                break;
            case "/" :                
                $result.value = numOne / numTwo;
                break; 
            default:
                break;   
        }
        $operator.value = '';
        numOne = $result.value;
        operator = '';
        numTwo = '';
    }
    else {
        alert("숫자를 먼저 입력하세요.")
    }

}

document.querySelector('#calculate').addEventListener('click', onClickCalculate);
```

#### 음수 값으로 시작하는 기능 추가

```javaScript
const onClickOperator = (op) => () => {
    if (numOne) {
        operator = op;
        $operator.value = op;
    }

    // 음수도 계산 가능
    else if (op == '-') {
        numOne = '-' + numOne;
    }

    else {
        alert('숫자를 먼저 입력하세요.')
    }
}
```

- 계산 시 오류를 방지하기 위해 소괄호를 씌워준다.

```javaScript
const onClickCalculate = () => {
    if (numTwo) {
        switch (operator) {
            case "+" :
                $result.value = (parseInt(numOne)) + parseInt(numTwo);
                break;
            case "-" :
                $result.value = (numOne) - numTwo;
                break;
            case "*" :
                $result.value = (numOne) * numTwo;
                break;
            case "/" :                
                $result.value = (numOne) / numTwo;
                break; 
            default:
                break;   
        }
        $operator.value = '';
        numOne = $result.value;
        operator = '';
        numTwo = '';
    }
    else {
        alert("숫자를 먼저 입력하세요.")
    }

}
```

#### 연달아 계산하기(= 이전에 연산자만으로 연달아 계산)

```javaScript
const onClickOperator = (op) => () => {
    if (numTwo) {
        switch (operator) {
            case "+" :
                $result.value = (parseInt(numOne)) + parseInt(numTwo);
                break;
            case "-" :
                $result.value = (numOne) - numTwo;
                break;
            case "*" :
                $result.value = (numOne) * numTwo;
                break;
            case "/" :                
                $result.value =(numOne) / numTwo;
                break; 
            default:
                break;   
        }
        numOne = $result.value;
        numTwo = '';
    }

    if (numOne) {
        operator = op;
        $operator.value = op;
    }

    else if (op == '-') {
        numOne = '-' + numOne;
    }

    else {
        alert('숫자를 먼저 입력하세요.')
    }
}

document.querySelector('#plus').addEventListener('click', onClickOperator('+'));
```

#### 계산기 전체코드

```javaScript
let numOne = '';
let operator = '';
let numTwo = '';
let result = '';
const $operator = document.querySelector('#operator')
const $result = document.querySelector('#result')
/*
고차함수로 중복 제거
const onClickNumber = (number) => () => {
    if (operator) {
        numTwo += number;
    } 
    else {
        numOne += number;
    }
    $result.value += number;
};
*/
// event 객체로 중복 제거
const onClickNumber = (event) => {
    if (!operator) {
        numOne += event.target.textContent;
        $result.value += event.target.textContent;
        return;
    } 

    if (!numTwo) {
        $result.value = '';
    }
    numTwo += event.target.textContent;
    $result.value += event.target.textContent;      
};

document.querySelector('#num-0').addEventListener('click', onClickNumber); 
document.querySelector('#num-1').addEventListener('click', onClickNumber);
document.querySelector('#num-2').addEventListener('click', onClickNumber);
document.querySelector('#num-3').addEventListener('click', onClickNumber);
document.querySelector('#num-4').addEventListener('click', onClickNumber);
document.querySelector('#num-5').addEventListener('click', onClickNumber); 
document.querySelector('#num-6').addEventListener('click', onClickNumber);
document.querySelector('#num-7').addEventListener('click', onClickNumber);
document.querySelector('#num-8').addEventListener('click', onClickNumber);
document.querySelector('#num-9').addEventListener('click', onClickNumber); 

const onClickOperator = (op) => () => {
    if (numTwo) {
        switch (operator) {
            case "+" :
                $result.value = (parseInt(numOne)) + parseInt(numTwo);
                break;
            case "-" :
                $result.value = (numOne) - numTwo;
                break;
            case "*" :
                $result.value = (numOne) * numTwo;
                break;
            case "/" :                
                $result.value =(numOne) / numTwo;
                break; 
            default:
                break;   
        }
        numOne = $result.value;
        numTwo = '';
    }

    if (numOne) {
        operator = op;
        $operator.value = op;
    }

    else if (op == '-') {
        numOne = '-' + numOne;
    }

    else {
        alert('숫자를 먼저 입력하세요.')
    }
}

document.querySelector('#plus').addEventListener('click', onClickOperator('+'));
document.querySelector('#minus').addEventListener('click', onClickOperator("-"));
document.querySelector('#divide').addEventListener('click', onClickOperator("/")); 
document.querySelector('#multiply').addEventListener('click', onClickOperator("*"));

const onClickCalculate = () => {
    if (numTwo) {
        switch (operator) {
            case "+" :
                $result.value = (parseInt(numOne)) + parseInt(numTwo);
                break;
            case "-" :
                $result.value = (numOne) - numTwo;
                break;
            case "*" :
                $result.value = (numOne) * numTwo;
                break;
            case "/" :                
                $result.value =(numOne) / numTwo;
                break; 
            default:
                break;   
        }
        // $operator.value = '';
        // numOne = $result.value;
        // operator = '';
        // numTwo = '';
    }
    else {
        alert("숫자를 먼저 입력하세요.")
    }

}

document.querySelector('#calculate').addEventListener('click', onClickCalculate);

const onClickClear = () => {
    numOne = '';
    operator = '';
    numTwo = '';
    $operator.value = '';
    $result.value = '';
}

document.querySelector('#clear').addEventListener('click', onClickClear);
```

### 숫자야구 순서도

<img width="308" alt="스크린샷 2023-04-11 오후 11 14 00" src="https://user-images.githubusercontent.com/96857599/231190928-8707357f-d22c-47ea-8166-0d9773de2c05.png">

### 랜덤 사용하기(Math.random)

Math.random은 0 <= Math.random() < 1 의 범위에서 랜덤한 값을 내준다.
Math.floor가 소수점을 없애주므로 Math.floor(Math.random() * 9 + 1) 로 랜덤한 1 이상 10 미만의 값을 준다.

<img width="280" alt="스크린샷 2023-04-11 오후 11 22 32" src="https://user-images.githubusercontent.com/96857599/231193341-72fa00b6-ca01-46cd-8e28-9653f120073b.png">

> 그러나 Math.random은 진짜 무작위가 아니다.

> Math.random()은 암호학적으로 완전한 무작위가 아닙니다. 따라서 보안과 관련된 작업(예를 들어 비밀번호를 생성한다거나)을 할 때는 Math.random()으로 생성된 수를 사용하면 위험합니다. 이를 위한 window.crypto.getRandomvalues() 함수가 따로 준비되어 있습니다.

**Math.random()은 암호학적으로 완전한 무작위가 아닌 이유**
- 균일한 분포 내에서 랜덤 정수를 생성하는데 사용되는 로직이 부적절하고 일반적으로 편향되어 있음
- 사용해야할 임의의 비트/바이트 수가 브라우저 별로 일치 하지 않음
- 무작위 결과값은 항상 일관되게 다시 생성하기 어려우므로, 이는 본질적으로 비결정적이고 불규칙함
- 빌트인 시드가 변조될 수 있으므로 무결성 측면에서 부적합

### 무작위로 숫자 네 개 뽑기

```javaScript
const numbers = [];
for (let n = 0; n < 9; n+=1) {
    numbers.push(n+1);
}

const answer = [];
for (let n = 0; n < 4; n+=1) {
    const index = Math.floor(Math.random() * numbers.length);
    answer.push(numbers[index]);
    numbers.splice(index, 1);
}
console.log(answer);
```

### 입력값 검증하기


- form이 서버에 데이터를 주고 받으며서 화면이 새로고침되면서 저장된 변수 날라감. 
    -> 기본동작이므로 제거할 수는 없고, 막을 것임.

```javaScript
$form.addEventListener('submit', (event) => {
    event.preventDefault(); // 기본동작 막기
    console.log("섭밋");
});
```

```javaScript
const tries = [];
function checkInput(input) {
    if (input.length !== 4) {
        return alert("4자리 숫자를 입력해 주세요.");
    }
    if (new Set(input).size !== 4) { // 집합 set 객체 사용해서 중복 제거
        return alert('중복되지 않게 입력해 주세요.')
    }
    if (tries.includes(input)) {
        return alert('이미 시도한 값입니다.');
    }
    return true;
}

$form.addEventListener('submit', (event) => {
    event.preventDefault(); // 기본동작 막기
    const value = $input.value;
    $input.value = '';
    if (checkInput(value)) {
        // 입력값 문제 없음
        tries.push(value);
    }
    else {
        // 에러 있음.
    }
});
```

### 홈런인지 검사해서 표시하기

```javaScript
$form.addEventListener('submit', (event) => {
    event.preventDefault(); // 기본동작 막기
    const value = $input.value;
    $input.value = '';
    if (!checkInput(value)) {
        return;
    }
    // 리스트.join(값) -> 리스트 사이를 값을 기준으로 합침
    if (answer.join('') === value) {
        $logs.textContent = "홈런!";
        return;
    }
    if (tries.length >= 9) {
        const message = document.createTextNode(`패배! 정답은 ${answer.join('')}`);
        $logs.appendChild(message);
        return;
    }
    // 입력값 문제 없음
    tries.push(value);
});
```

### 몇 볼 몇 스트라이크인지 계산

```javaScript
$form.addEventListener('submit', (event) => {
    //... 홈런인지 검사해서 표시하기
    
    // 몇 볼 몇 스트라이크인지 계산
    let strike = 0;
    let ball = 0;
    for (let i = 0; i < 3; i++) {
        const index = value.indexOf(answer[i]);
        if (index > -1) { // 일치할 때
            if (index === i) {
                strike += 1;
            }
            else {
                ball += 1;
            }
        }
    }
    // document.createElement('br') 줄 넘김 태그 추가
    $logs.append(`${value}: ${strike} 스트라이크 ${ball} 볼`, document.createElement('br'));
    // 입력값 문제 없음
    tries.push(value);
});
```

### 아웃 만들기

```javaScript
if (strike + ball == 0) {
    out++;
    $logs.append(`${value}: ${strike} 스트라이크 ${ball} 볼, 아웃!!! ${out} 번째 아웃!!`, document.createElement('br'));
}
else {
     // document.createElement('br') 줄 넘김 태그 추가
    $logs.append(`${value}: ${strike} 스트라이크 ${ball} 볼`, document.createElement('br'));
}

if (out===3) {
    const message = document.createTextNode(`패배! 정답은 ${answer.join('')}`);
    $logs.append(message);
    return;
}
```

**전체 코드**

```javaScript

const $input = document.querySelector("#input");
const $form = document.querySelector("#form");
const $logs = document.querySelector("#logs");
const $result = document.querySelector("#result");

// const numbers = [];
// for (let n = 0; n < 9; n+=1) {
//     numbers.push(n+1);
// }

const numbers = Array(9).fill(0).map((el, i) => {
    return el += i + 1
});

const answer = [];
for (let n = 0; n < 4; n+=1) {
    const index = Math.floor(Math.random() * numbers.length);
    answer.push(numbers[index]);
    numbers.splice(index, 1);
}
console.log(answer);

// form이 서버에 데이터를 주고 받으며서 화면이 새로고침되면서 저장된 변수 날라감. 
// -> 기본동작이므로 제거할 수는 없고, 막을 것임.

const tries = [];
function checkInput(input) {
    if (input.length !== 4) {
        return alert("4자리 숫자를 입력해 주세요.");
    }
    if (new Set(input).size !== 4) { // 집합 set 객체 사용해서 중복 제거
        return alert('중복되지 않게 입력해 주세요.')
    }
    if (tries.includes(input)) {
        return alert('이미 시도한 값입니다.');
    }
    return true;
}


let out = 0;
$form.addEventListener('submit', (event) => {
    event.preventDefault(); // 기본동작 막기
    const value = $input.value;
    $input.value = '';
    if (!checkInput(value)) {
        return;
    }
    // 리스트.join(값) -> 리스트 사이를 값을 기준으로 합침
    if (answer.join('') === value) {
        $logs.textContent = "홈런!";
        $result.append(`${tries.length + 1} 번 시도만에 성공!`);
        return;
    }
    if (tries.length >= 9) {
        defeated();
        return;
    }

    function defeated() {
        const message = document.createTextNode(`패배! 정답은 ${answer.join('')}`);
        $logs.append(message);
    }

    let strike = 0;
    let ball = 0;
    for (let i = 0; i < 3; i++) {
        const index = value.indexOf(answer[i]);
        if (index > -1) { // 일치할 때
            if (index === i) {
                strike += 1;
            }
            else {
                ball += 1;
            }
        }
    }
    if (strike + ball == 0) {
        out++;
        $logs.append(`${value}: ${strike} 스트라이크 ${ball} 볼, 아웃!!! ${out} 번째 아웃!!`, document.createElement('br'));
    }
    else {
         // document.createElement('br') 줄 넘김 태그 추가
        $logs.append(`${value}: ${strike} 스트라이크 ${ball} 볼`, document.createElement('br'));
    }

    if (out===3) {
        defeated();
        return;
    }
    // 입력값 문제 없음
    tries.push(value);
});
```

### forEach, map, fill 알아보기

#### forEach

forEach(배열 값, 값의 인덱스)
- 배열의 값과 값의 인덱스를 차례로 넣어준다.

<img width="216" alt="스크린샷 2023-04-12 오전 1 07 37" src="https://user-images.githubusercontent.com/96857599/231223175-abc15933-1764-4b86-84e4-b235fed31df6.png">

#### map

**원래 배열을 안 바뀌는 것 유의**

<img width="219" alt="스크린샷 2023-04-12 오전 1 09 15" src="https://user-images.githubusercontent.com/96857599/231223572-854c670e-bcf0-42ac-96a3-faa6e02b0461.png">


#### fill
- 배열을 쉽게 채워줄 수 있다.

#### fill과 map을 이용해서 간단하게 원하는 배열을 만들 수 있다.

<img width="248" alt="스크린샷 2023-04-12 오전 1 12 51" src="https://user-images.githubusercontent.com/96857599/231224444-66b14882-5804-4118-9493-ab3454a23c49.png">

- 숫자 야구에서 수정

```javaScipt
 // const numbers = [];
// for (let n = 0; n < 9; n+=1) {
//     numbers.push(n+1);
// }

const numbers = Array(9).fill(0).map((el, i) => {
    return el += i + 1
});
``` 

### 로또 추첨기 순서도

<img width="603" alt="스크린샷 2023-04-12 오후 8 52 50" src="https://user-images.githubusercontent.com/96857599/231448881-2fd52285-17b9-4032-9db2-b9bc5f5d5d79.png">

#### 동기
- 한 작업이 실행되는 동안 다른 작업은 멈춘 상태를 유지하고 자신의 차례를 기다리는 것
- Call Stack에 쌓여서 LIFO 방식으로 실행되는 것

#### 비동기
- 어떠한 요청을 보내면 그 요청이 끝날 때까지 기다리는 것이 아니라, 응답에 관계없이 바로 다음 동작이 실행되는 방식
- 지금까지 썼던 이벤트 리스너가 대표적인 비동기 코드이다.

**비동기 작동 방식**

- Call Stack에서 비동기 함수가 호출되면 Call Stack에 먼저 쌓였다가 Web API(혹은 백그라운드라고도 한다)로 이동한 후 해당 함수가 등록되고 Call Stack에서 사라진다.
- Web API(백그라운드)에서 비동기 함수의 이벤트가 발생하면, 해당 콜백 함수는 Callback Queue에 push(이동) 된다.
- 이제 Call Stack이 비어있는지 이벤트 루프(Event Loop)가 확인을 하는데 만약 비어있으면, Call Stack에 Callback Queue에 있는 콜백 함수를 넘겨준다.(push)
- Call Stack에 들어온 함수는 실행이 되고 실행이 끝나면 Call Stack에서 사라진다. 

#### 로또 추첨기 순서도
<img width="96" alt="스크린샷 2023-04-12 오후 8 53 44" src="https://user-images.githubusercontent.com/96857599/231449075-9bf8445c-eb5e-4232-b1ea-6253a9353ce6.png">


#### 피셔-에이츠 셔플 알고리즘으로 랜덤한 순서의 로또 배열 생성
 
```javaScript
const candidate =Array(45).fill().map((v, i) => i + 1);
const shuffle = [];
for (let i = candidate.length; i > 0; i--) {
    const random = Math.floor(Math.random() * i);
    const spliceArray = candidate.splice(random, 1) // 길이가 1인 배열이 나옴
    const value = spliceArray[0];
    shuffle.push(value);
}
// while (candidate.length > 0) {
//     const random = Math.floor(Math.random() * candidate.length);
//     const spliceArray = candidate.splice(random, 1) // 길이가 1인 배열이 나옴
//     const value = spliceArray[0];
//     shuffle.push(value);
// }
console.log(shuffle);
const winBalls = shuffle.slice(0, 6).sort((a,b) => a - b);
const bonus = shuffle[6];
console.log(winBalls, bonus)
```

### 공 정렬하기(sort)

- sort()는 원본 배열을 정렬 후 바꿔버린다.

<img width="213" alt="스크린샷 2023-04-12 오후 9 29 05" src="https://user-images.githubusercontent.com/96857599/231457093-9c496b06-421f-4052-8ef0-814396b642db.png">

- 이때 .slice()로 얕은 복사를 이용하면 원본 배열을 바꾸지 않고 이용할 수 있다.

<img width="287" alt="스크린샷 2023-04-12 오후 9 30 55" src="https://user-images.githubusercontent.com/96857599/231457628-d0718051-004f-4913-a9c1-1b91e11f08f1.png">

- 내림차순도 가능

<img width="298" alt="스크린샷 2023-04-12 오후 9 31 35" src="https://user-images.githubusercontent.com/96857599/231457807-d9956221-087a-463d-b47f-a79aa387dda2.png">

- 문자열도 정렬 가능

<img width="369" alt="스크린샷 2023-04-12 오후 9 34 44" src="https://user-images.githubusercontent.com/96857599/231458615-850399e0-2901-4c9b-b9b0-ad4d867e805c.png">

- 모든 문자열에 대해 사전순 정렬

<img width="383" alt="스크린샷 2023-04-12 오후 9 36 12" src="https://user-images.githubusercontent.com/96857599/231459040-9f123791-bc15-4212-8314-17ed38cc4d86.png">

### 일정 시간 후 실행하기

**사용법**

```javaScript
setTimeout(() => {
    // 내용
}, ms);

**시간 설정 및 공 생성 코드**

```javaScript
const $result = document.querySelector("#result");
const $bonus = document.querySelector("#bonus");
function showBall(number, $target) {
    // $ball 이라는 변수에 div 태그와 그 클래스 이름을 ball로 설정하고 로또 번호를 값으로 설정한 후,
    // $target 하위로 추가해준다.
    const $ball = document.createElement("div");
    $ball.className = 'ball';
    $ball.textContent = number;
    $target.appendChild($ball);
}
for (let i = 0; i < winBalls.length; i++) {
    setTimeout(() => {
        showBall(winBalls[i], $result)
    }, (i + 1) * 1000);
}

setTimeout(() => {
    showBall(bonus, $bonus)
}, 7000);
```

<img width="1251" alt="스크린샷 2023-04-13 오전 12 08 30" src="https://user-images.githubusercontent.com/96857599/231501051-795b4a08-4afd-4c12-a470-4915e1685aba.png">

#### js의 타이머 시간은 정확한가?

- 자바스크립트는 기본적으로 한 번에 한 가지 일만 할 수 있습니다.
- 따라서 이미 많은 일을 하고 있다면, 설정한 시간이 되어도 setTimeout에 지정된 작업이 수행되지 않습니다.
- 기존에 하고 있던 일이 끝나야 setTimeout 에 지정한 작업이 실행됩니다


### 블록, 함수 스코프, 클로저 문제

#### var와 let의 차이 이해하기

```javaScript
for (let i = 0; i < winBalls.length; i++) {
    setTimeout(() => {
        console.log(winBalls[i],i)
        showBall(winBalls[i], $result)
    }, (i + 1) * 1000);
}
```

위 반복문에서 i를 let에서 var로 바꿔보자

- let 일 때
<img width="1251" alt="스크린샷 2023-04-13 오전 12 20 13" src="https://user-images.githubusercontent.com/96857599/231504223-936494d1-2f31-4242-bb1c-b2aee91da22e.png">

- var 일 때
<img width="1251" alt="스크린샷 2023-04-13 오전 12 19 50" src="https://user-images.githubusercontent.com/96857599/231504115-a3556c3f-bc5e-46ea-820c-243b374bb7d2.png">

**왜 이런 일이 생긴 걸까? 그리고 var에서는 왜 6이라는 숫자가 나온걸까?**

- 변수는 스코프(scope, 범위)라는 것을 가집니다. var는 함수 스코프를 가지고, let 은 블록 스코프를 가집니다. 

<img width="271" alt="스크린샷 2023-04-13 오전 12 27 35" src="https://user-images.githubusercontent.com/96857599/231506345-bd81f587-746c-4177-b409-a09b367057db.png">

- 위에서 알 수 있듯이, let은 블록 스코프이기 때문에 for문이 끝난 후 사라지지만, var는 함수 스코프를 가지므로 그 값이 그대로 남아있어 5를 출력한 것이다.

**실습코드의 경우 var와 let의 스코프 범위 차이로 인한 문제와 클로저 문제가 합쳐졌다.**

```javaScript
for (var i = 0; i < winBalls.length; i++) {
    setTimeout(() => {
        console.log(winBalls[i],i) 
        showBall(winBalls[i], $result)
    }, (i + 1) * 1000);
}
```

- for 문은 동기 실행이고, 아래의 코드는 비동기 실행이므로

```javaScript
() => {
        console.log(winBalls[i],i)
        showBall(winBalls[i], $result)
    }
```

- 위의 코드가 실행될 때는 이미 i가 6인 상태이다. 때문에 winBalls[6]은 undefined인 것이고 i는 6이 출력되는 것이다.

**그럼 let은 왜 되는가?**

- for 문에서 쓰이는 let 은 하나의 블록마다 i가 고정됩니다. 이것도 블록 스코프의 특성이라고 보면 됩니다. 
- 따라서 setTimeout 콜백 함수 내부의 i도 setTimeout을 호출할 때의 i와 같은 값이 들어갑니다.

- 반복문과 var 를 쓸 때 항상 스코프 관련 문제가 생기는 것은 아닙니다. 
- setTimeout 같은 비동기 함수와 반복문, var 를 만나면 이런 문제가 발생합니다.

**var로 문제 해결하기(클로저로 문제 해결하기)**

```javaScript
for (var i = 0; i < winBalls.length; i++) {
    (function(j) {
        setTimeout(() => {
            console.log(winBalls[j],j) 
            showBall(winBalls[j], $result)
        }, (j + 1) * 1000);
    })(i);
}
```

- 클로저란: 함수와 함수 바깥에 있는 변수와의 관계

### css 접근- 공 색칠하기

```javaScript
function colorize(number, $tag) {
    if (number < 10) {
        $tag.style.backgroundColor = "red";
        $tag.style.color = "white";
    } 
    else if (number < 20) {
        $tag.style.backgroundColor = "orange";
    }
    else if (number < 30) {
        $tag.style.backgroundColor = "yellow";
    }
    else if (number < 40) {
        $tag.style.backgroundColor = "blue";
        $tag.style.color = "white";
    }
    else {
        $tag.style.backgroundColor = "green";
        $tag.style.color = "white";
    }
}
```

**전체 코드**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .ball {
            display: inline-block;
            border: 1px solid black;
            border-radius: 20px;
            width: 40px;
            height: 40px;
            line-height: 40px;
            font-size: 20px;
            text-align: center;
            margin-right: 20px;
        }
    </style>
</head>
<body>
    <div id="result">추첨 결과는?</div>
    <div id="bonus">보너스: </div>
    <script>
        const candidate =Array(45).fill().map((v, i) => i + 1);
        const shuffle = [];
        for (let i = candidate.length; i > 0; i--) {
            const random = Math.floor(Math.random() * i);
            const spliceArray = candidate.splice(random, 1) // 길이가 1인 배열이 나옴
            const value = spliceArray[0];
            shuffle.push(value);
        }
        // while (candidate.length > 0) {
        //     const random = Math.floor(Math.random() * candidate.length);
        //     const spliceArray = candidate.splice(random, 1) // 길이가 1인 배열이 나옴
        //     const value = spliceArray[0];
        //     shuffle.push(value);
        // }
        console.log(shuffle);
        const winBalls = shuffle.slice(0, 6).sort((a,b) => a - b);
        const bonus = shuffle[6];
        console.log(winBalls, bonus)

        const $result = document.querySelector("#result");
        const $bonus = document.querySelector("#bonus");
        function showBall(number, $target) {
            // $ball 이라는 변수에 div 태그와 그 클래스 이름을 ball로 설정하고 로또 번호를 값으로 설정한 후,
            // $target 하위로 추가해준다.
            const $ball = document.createElement("div");
            $ball.className = 'ball';
            colorize(number, $ball);
            $ball.textContent = number;
            $target.appendChild($ball);
        }
        for (var i = 0; i < winBalls.length; i++) {
            (function(j) {
                setTimeout(() => {
                    console.log(winBalls[j],j) 
                    showBall(winBalls[j], $result)
                }, (j + 1) * 1000);
            })(i);
        }

        setTimeout(() => {
            showBall(bonus, $bonus)
        }, 7000);
        
        function colorize(number, $tag) {
            if (number < 10) {
                $tag.style.backgroundColor = "red";
                $tag.style.color = "white";
            } 
            else if (number < 20) {
                $tag.style.backgroundColor = "orange";
            }
            else if (number < 30) {
                $tag.style.backgroundColor = "yellow";
            }
            else if (number < 40) {
                $tag.style.backgroundColor = "blue";
                $tag.style.color = "white";
            }
            else {
                $tag.style.backgroundColor = "green";
                $tag.style.color = "white";
            }
        }
            
    </script>
</body>
</html>
```

### 가위바위보

### 객체 생성
- 객체명은 고유한 것으로 설정

```javaScript
const rspX = {
    scissors: '0',
    rock: '-200px',
    paper: '-440px',
};
```

### 타이머 사용하기(setInterval)

#### setInterval
- setTimeout 과 비슷한 효과를 냅니다. 다만, 한 번 실행되고 마는 setTimeout 과는 다르게 지정한 시간마다 주기적으로 지정한 함수를 실행합니다.

```javaScript
let computerChoice = 'scissors';
const changeComputerHand = () => {
    if (computerChoice === 'scissors') { 
        computerChoice = 'rock';

    } 
    else if (computerChoice === 'rock') {
        computerChoice = 'paper';

    }
    else if (computerChoice === 'paper') { 
        computerChoice = 'scissors';
    }
    $computer.style.background = `url(${IMG_URL}) ${rspX[computerChoice]} 0`;
    $computer.style.backgroundSize = 'auto 200px'

}

let intervalId = setInterval(changeComputerHand, 50);
```

- 비슷한 방법으로 setTimeout을 사용할 수 있다.

```javaScript
let computerChoice = 'scissors';
const changeComputerHand = () => {
    if (computerChoice === 'scissors') { 
        computerChoice = 'rock';

    } 
    else if (computerChoice === 'rock') {
        computerChoice = 'paper';

    }
    else if (computerChoice === 'paper') { 
        computerChoice = 'scissors';
    }
    $computer.style.background = `url(${IMG_URL}) ${rspX[computerChoice]} 0`;
    $computer.style.backgroundSize = 'auto 200px'
    setTimeout(changeComputerHand, 50);
}

let intervalId = setTimeout(changeComputerHand, 50);
```


### 타이머 멈췄다 다시 실행

```javaScript
const clickButton = () => {
    clearInterval(intervalId);

    setTimeout(() => {
        intervalId = setInterval(changeComputerHand, 50);
    }, 1000);
}

$rock.addEventListener('click', clickButton);
$scissors.addEventListener('click', clickButton);
$paper.addEventListener('click', clickButton);
```

**버튼을 여러번 클릭할 수록 빨라지는 이유**

- clickButton 5번 호출, 인터벌 1번, 2번, 3번, 4번, 5번(얘만 intervalId) 그 다음에 버튼을 클릭하면 5번만 취소
- 1~4번은 취소되지 않고 계속 돌아감

#### 위 문제의 해결 코드
1. 버튼 클릭 시 변수를 변경시켜 조건에 맞는 변수일 때만 실행

```javaScript
let clickable = true;
const clickButton = () => {
    if (clickable) {
        clearInterval(intervalId);
        clickable = false;
        // 점수 계산 및 화면 표시
        setTimeout(() => {
            clickable = true; 
            clearInterval(intervalId);
            intervalId = setInterval(changeComputerHand, 50);
        }, 1000);
    }

}
```
2. removeEventListener 사용

```javaScript
$rock.removeEventListener('click', clickButton);
$scissors.removeEventListener('click', clickButton);
$paper.removeEventListener('click', clickButton);
```

### removeEventListener 주의점

```javaScript
const fun = (값) => () => {
    console.log('고차함수입니다', 값);
}
태그.addEventListener('click', fun(1));
태그.removeEventlistener('click', fun(1)); // 태그.addEventListener('click', fun(1));을 멈추고자 넣어준 것임. 그러나 이것은 이벤트를 제거하지 않음.
```

-> 이유는 태그.addEventListener('click', fun(1));에서의 fun(1)과 태그.removeEventlistener('click', fun(1));의 fun(1)이 다른 객체이기 때문이다.

- 해결방법: 변수에 객체를 넣어서 그 변수를 재사용한다.

```javaScript
const fun = (값) => () => {
    console.log('고차함수입니다', 값);
}
const fun1 = fun(1)
태그.addEventListener('click', fun1);
태그.removeEventlistener('click', fun1); 
```

### 가위바위보 규칙

- 가위: 1, 바위: 0, 보: -1 이라고 할 때, 각 값을 빼면 아래의 규칙이 생긴다.

<img width="415" alt="스크린샷 2023-04-13 오후 7 52 22" src="https://user-images.githubusercontent.com/96857599/231737227-f423297b-3854-4797-a4d6-8c14c1b2f6b0.png">


```javaScript
let clickable = true;
let score = 0;
const clickButton = () => {
    if (clickable) {
        clearInterval(intervalId);
        clickable = false;

        // 점수 계산 및 화면 표시
        const myChoice = event.target.textContent === '바위' 
        ? 'rock' 
        : event.target.textContent === '가위' 
            ? 'scissors' 
            : 'paper';
        const myScore = scoreTable[myChoice];
        const computerScore = scoreTable[computerChoice];
        const diff = myScore - computerScore;

        let message;
        // 2, -1은 승리조건이고, -2, 1은 패배조건, 점수표 참고
        if ([2, -1].includes(diff)) {
            score += 1;
            message = '승리';
        } else if ([-2, 1].includes(diff)) {
            score -= 1;
            message = '패배';
        } else {
            message = '무승부';
        }
        $score.textContent = `${message} 총: ${score}점`;
        setTimeout(() => {
            clickable = true; 
            intervalId = setInterval(changeComputerHand, 50);
        }, 1000);
    }

}
```

**꿀팁**
- 위 코드를 아래의 코드로 바꿔쓸 수 있다.

```javaScript
diff === 2 || diff === -1
// 또는
[2, -1].includes(diff)
```

### 3판 2선승제

```javaScript
const $computer = document.querySelector('#computer');
const $score = document.querySelector('#score');
const $rock = document.querySelector('#rock');
const $scissors = document.querySelector('#scissors');
const $paper = document.querySelector('#paper');
const IMG_URL = './rsp.png';
$computer.style.background = `url(${IMG_URL}) -464px 0`;
$computer.style.backgroundSize = 'auto 200px';

const rspX = {
    scissors: '0', // 가위
    rock: '-220px', // 바위
    paper: '-440px', // 보
};

let computerChoice = 'scissors';
const changeComputerHand = () => {
    if (computerChoice === 'rock') { // 바위면
        computerChoice = 'scissors';
    } 
    else if (computerChoice === 'scissors') { // 가위면
        computerChoice = 'paper';
    } 
    else if (computerChoice === 'paper') { // 보면
        computerChoice = 'rock';
    }
    $computer.style.background = `url(${IMG_URL}) ${rspX[computerChoice]} 0`;
    $computer.style.backgroundSize = 'auto 200px';
}
let intervalId = setInterval(changeComputerHand, 50);

const scoreTable = {
    rock: 0,
    scissors: 1,
    paper: -1,
};

// clickButton 5번 호출, 인터벌 1번, 2번, 3번, 4번, 5번(얘만 intervalId)
//  그 다음에 버튼을 클릭하면 5번만 취소
let clickable = true;
let computer = 0;
let me = 0;
const clickButton = (event) => {
    if (clickable) {
        clearInterval(intervalId);
        clickable = false;
        // 점수 계산 및 화면 표시
        const myChoice = event.target.textContent === '바위' 
            ? 'rock' 
            : event.target.textContent === '가위' 
                ? 'scissors' 
                : 'paper';
        const myScore = scoreTable[myChoice];
        const computerScore = scoreTable[computerChoice];
        const diff = myScore - computerScore;

        let message;
        // 2, -1은 승리조건이고, -2, 1은 패배조건, 점수표 참고
        if ([2, -1].includes(diff)) {
            me += 1;
            message = '승리';
        }
        else if ([-2, 1].includes(diff)) {
            computer += 1;
            message = '패배';
        } 
        else {
            message = '무승부';
        }

        if (me === 3) {
            $score.textContent = `나의 승리 ${me}:${computer}`;
        } 
        else if (computer === 3) {
            $score.textContent = `컴퓨터의 승리 ${me}:${computer}`;
        } 
        else {
            $score.textContent = `${message} ${me}:${computer}`;
            setTimeout(() => {
                clickable = true;
                intervalId = setInterval(changeComputerHand, 50);
            }, 1000);
        }
    }
}; 

$rock.addEventListener('click', clickButton);
$scissors.addEventListener('click', clickButton);
$paper.addEventListener('click', clickButton);
```

### 반응속도 체크 순서도

<img width="354" alt="스크린샷 2023-04-13 오후 8 36 10" src="https://user-images.githubusercontent.com/96857599/231746883-31148467-226b-4993-8fc7-342c5b0c5601.png">

### 클릭해서 화면 전환하기

- 태그에 해당 클래스가 들어 있는지 다음 방법으로 알 수 있다.

태그.classList.contains('클래스');

-> 해당 클래스가 들어 있다면 true, 들어있지 않다면 false 가 됩니다.

태그.classList.add('클래스'); // 추가
태그.classList.replace('기존 클래스', '수정클래스'); // 수정
태그.classList.remove('클래스'); // 제거

**활용**

```javaScript
const $screen = document.querySelector('#screen');
const $result = document.querySelector('#result');
let startTime;
let endTime;

$screen.addEventListener('click', (event) => {
    if (event.target.classList.contains('waiting')) { // 파랑
        $screen.classList.remove('waiting');
        $screen.classList.add('ready');
        $screen.textContent = '초록색이 되면 클릭하세요';
        setTimeout(function () {
            startTime = new Date();
            $screen.classList.remove('ready');
            $screen.classList.add('now');
            $screen.textContent = '클릭하세요!';
        }, Math.floor(Math.random() * 1000) + 2000); // 2초에서 3초 사이 2000~3000 사이 수
    }

    else if ($screen.classList.contains('ready')) { // 빨강
    }
    else if ($screen.classList.contains('now')) { // 초록
    }


});
```

### 반응속도 측정하기

- 현재 시작을 얻어보자.

```javaScript
new Date();

// 과거 시간
new Date(연, 월(0부터 시작), 일 , 시간, 분, 초);
```

- toLocaleDateString()을 이용하면 각 나라에서 사용하는 형태로 변환

**활용**

```javaScript
else if ($screen.classList.contains('now')) { // 초록
    endTime = new Date();
    $result.textContent = `${endTime - startTime}ms`;
    $screen.classList.remove('now');
    $screen.classList.add('waiting');
    $screen.textContent = '클릭해서 시작하세요';
}
```

### 평균 반응속도 구하기


- 평균 반응속도를 구하기 위해, records라는 배열에 반응속도 기록


```javaScript
const records = [];
else if ($screen.classList.contains('now')) { // 초록
    endTime = new Date();
    const current = endTime - startTime;
    records.push(current);
    const average = records.reduce((a, c) => a + c) /records.length;
    $result.textContent = `현재 ${current}ms, 평균: ${average}ms`;
    startTime = null;
    endTime = null;
    $screen.classList.remove('now');
    $screen.classList.add('waiting');
    $screen.textContent = '클릭해서 시작하세요';
}
```

**reduce**
배열.reduce((a(누적값),c(현재값), i(인덱스)) => 수행 연산, 초기값)
-> a 는 누적값이고 c에는 배열의 값이 순서대로 들어간다.
-> 초기값 설정 안 하면 첫번째값이 초기값

<img width="231" alt="스크린샷 2023-04-14 오후 10 30 33" src="https://user-images.githubusercontent.com/96857599/232057351-2564c2a7-1cb6-47cd-9ab7-a1442ca4479d.png">

- 배열을 객체로
<img width="231" alt="스크린샷 2023-04-14 오후 10 30 33" src="https://user-images.githubusercontent.com/96857599/232057351-2564c2a7-1cb6-47cd-9ab7-a1442ca4479d.png">

실행 순서
```
a: {}, c: "a", i = 0
a: {0: "a"}, c: "b", i = 1
a: {0: "a", 1: "b"}, c: "c", i = 2
a: {0: "a", 1: "b", 2: "c"}, c: "d", i = 3
a: {0: "a", 1: "b", 2: "c", 3: "d"}
```


### 성급한 클릭 막기

- 예측 클릭 막기

```javaScript
let timeoutId;

...

    if (event.target.classList.contains('waiting')) { // 파랑
        $screen.classList.remove('waiting');
        $screen.classList.add('ready');
        $screen.textContent = '초록색이 되면 클릭하세요';
        timeoutId = setTimeout(function () {
            startTime = new Date();
            $screen.classList.remove('ready');
            $screen.classList.add('now');
            $screen.textContent = '클릭하세요!';
        }, Math.floor(Math.random() * 1000) + 2000); // 2초에서 3초 사이 2000~3000 사이 수
    }

    else if ($screen.classList.contains('ready')) { // 빨강
        // 빨강으로 넘어왔을 때 클릭하면, 처음으로 되돌아가야하는데
        // 아직 파랑일 때의 타이머가 돌고 있기 때문에 취소해야한다.
        clearTimeout(timeoutId); 
        $screen.classList.remove('ready');
        $screen.classList.add('waiting');
        $screen.textContent = '너무 성급하시군요!';
    }

```

**전체코드**
```javaScript
const $screen = document.querySelector('#screen');
const $result = document.querySelector('#result');
let startTime;
let endTime;
const records = [];
let timeoutId;


$screen.addEventListener('click', (event) => {
    if (event.target.classList.contains('waiting')) { // 파랑
        $screen.classList.remove('waiting');
        $screen.classList.add('ready');
        $screen.textContent = '초록색이 되면 클릭하세요';
        timeoutId = setTimeout(function () {
            startTime = new Date();
            $screen.classList.remove('ready');
            $screen.classList.add('now');
            $screen.textContent = '클릭하세요!';
        }, Math.floor(Math.random() * 1000) + 2000); // 2초에서 3초 사이 2000~3000 사이 수
    }

    else if ($screen.classList.contains('ready')) { // 빨강
        // 빨강으로 넘어왔을 때 클릭하면, 처음으로 되돌아가야하는데
        // 아직 파랑일 때의 타이머가 돌고 있기 때문에 취소해야한다.
        clearTimeout(timeoutId); 
        $screen.classList.remove('ready');
        $screen.classList.add('waiting');
        $screen.textContent = '너무 성급하시군요!';
    }
    else if ($screen.classList.contains('now')) { // 초록
        endTime = new Date();
        const current = endTime - startTime;
        records.push(current);
        const average = records.reduce((a, c) => a + c) /records.length;
        $result.textContent = `현재 ${current}ms, 평균: ${average}ms`;
        startTime = null;
        endTime = null;
        $screen.classList.remove('now');
        $screen.classList.add('waiting');
        $screen.textContent = '클릭해서 시작하세요';
    }


});

```


### 속도 순으로 정렬

```javaScript
else if ($screen.classList.contains('now')) { // 초록
        endTime = new Date();
        const current = endTime - startTime;
        records.push(current);
        const average = records.reduce((a, c) => a + c) /records.length;
        $result.textContent = `현재 ${current}ms, 평균: ${average}ms`;

        // 속도 순으로 정렬 
        const topFive = records.sort((a, c) => a - c).slice(0, 5);
        // $result에 추가 
        topFive.forEach((el, i) => {
            $result.append(
                document.createElement('br'),
                `${i + 1}위: ${el}ms`,
            );
        });

        startTime = null;
        endTime = null;
        $screen.classList.remove('now');
        $screen.classList.add('waiting');
        $screen.textContent = '클릭해서 시작하세요';
    }
```

### 정리

1. 자바스크립트에서 실제 불리언 값이 아니더라도 문맥상 참, 거짓으로 판단하는 값들에는 뭐가 있을까? 그리고 이것들을 뭐라고 부를까?

-> Truthy와 Falsy값이라고 부르며, 다음과 같은 예시가 있습니다!
Truthy값: 비어있지 않은 모든 문자열, 0이 아닌 모든 숫자, {}, [],
Falsy값: 0, -0, "", null, undefined, NaN

2. 문자열을 표현하는데에 사용된 문법은 무엇일까? (백틱 문자열 표현에 관하여)
템플릿 리터럴(Template Literal)으로 백틱을 사용해 문자열을 표현할 수 있고, 추가로 ${}은 표현식 삽입(Expression interpolation)이라는 문법입니다!



















