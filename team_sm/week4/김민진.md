# week4

### 세미콜론

- 하나의 명령이 끝날 때 세미콜론을 붙이기를 권장한다.

```jsx
console.loge('hello, world');
```

### 주석

- 사람만 알아볼 수 있도록 설명을 작성하는 부분이다.
- 코드에 대한 자세한 설명을 작성하거나 특정 코드를 임시로 사용하지 않도록 만들 때 사용한다.

```jsx
//주석-설명을 작성한다.
/*주석-설명을 작성한다.*/
```

### 자료형

- 값(value)은 프로그램이 조작할 수 있는 데이터를 의미한다.
- 값에는 여러 가지 종류가 있으며 이런 값의 종류를 자료형(data type)이라고 한다.
- 문자열(string)
    - 프로그래밍에서 하나의 글자를 문자라고 하는데 문자들이 하나 이상 나열되어 있으면 문자열이라고 한다.
    - 따옴표(””, ‘’), 백틱(`)로 감싸줘야 한다.
    - `는 문자열에서 줄바꿈을 할 수 있다.
    - \n을 사용하면 줄바꿈을 사용할 수 있다.
    - `typeof ‘문자열’` 로도 작성이 가능하다.
    - 사용하고 싶은 따옴표랑 다른 따옴표로 감싸주면 출력된다.
    - 같은 따옴표를 사용하고 싶다면 `‘how\'re you'`로 입력하면 된다.
    - `문자열\\입력` 시 `문자열\입력` 으로 출력된다.
    - 문자열끼리 더하기가 가능하다.
- 숫자
    - 사칙연산이 가능하다.
    - 모든 진법 작성이 가능하다.
    - `5e-4` 는 `0.0005`로 출력된다.
    - `5e4`는 `50000`으로 출력된다.
    - NaN=not a number
    - `“1234”` 는 문자열이고 `1234`는 숫자다.
    - `parseInt()` : 정수를 반환한다. “4월”이라 입력시 4만 출력된다.
    - `Number()` : 숫자만 읽는다. “4월”이라고 입력시 출력되지 않는다.
    - `pronpt()` : 입력한 값이 나온다.
    - `parseInt(prompt())` : 입력한 값의 정수가 나온다.
    - `typeof parseInt(prompt())` : 입력한 값이 무엇인지 알려준다. 54를 입력시 number가 출력된다.
    - 연산자 우선 순위: ()사용시 1순위가 된다.
- 불 값
    - true와 false를 나타내는 boolean이라는 자료형이 있다.
    - `==` `>` `<` `<=` `>=` `!=`
    - 특수문자 비교시 `.charCodeAT()`를 상용한다.
    - NaN은 어떤한 값이랑 비교를 해도 false가 나온다.
    - `==` 와 `===`의 차이: `===`을 사용하면 값 비교 뿐만 아니라 자료형까지 비교한다.

### 논리 연산자

- `||` :또는, 그리고
- `flase`, `‘’`(빈 문자열), `0`, `NaN`, `undefined`, `nul`l은 불 값으로 형 변환했을 대 flase가 된다.(`document.all` 또한 false이지만 잘 사용되지 않는다.)
- 나머지는 ture이다.
- `!` 는 반대이고 `!!` 는 다시 참이된다.

### undefined, null

- undefined: 반환해줄 값이 없다.
- undefined==null ture
- undefined===null flase
- typeof null
    - 결과값이 “null”이 아니라 “object”이다.
    - 값이 null인지 확인하기 위해서는 === null을 사용해야한다.
- null과 undefined는 둘 다 빈 값이다.
- undefined는 기본값이라는 의미라도 있지만 null은 역할이 없다는 차이점이 있다.

### 변수

- 프로그램을 만들 때는 잠깐 동안 특정한 값을 저장해야 하는 상황이 자주 발생하는데 이때 사용하는 것이 변수이다.

```jsx
let string = 1234;
```

- 선언문: let으로 시작하는 명령이다.
- string 자리는 변수명이다.
- 초기화: 변수를 선언함과 동시에 값을 대입하는 행위이다.
- 변수의 이름과 값은 컴퓨터의 메모리에 저장된다.
- 변수명 짓기
    - 한글, 한자, 영어 다 사용가능하다.
    - 숫자를 사용할 때는 제일 처음에 나오면 안된다.
    - 대문자도 가능하다.
    - 특수문자는 $_가 주로 가능하다.
    - let, class, const 등의 예약어는 변수명으로 사용이 불가능하다.(let은 예약어가 아니다.)
- 변수 수정하기
    - 변수 수정시 let은 다시 작성하면 안된다.
    
    ```jsx
    let change = '바꾼다.';
    change = '바꿨다.';
    ```
    
    - let으로 변수를 선언할 때는 콘솔의 결괏값이 undefined이지만, 변수의 값을 바꿀 때는 결괏값이 바꾼 값이 된다.
    - let이 없을 때는 코드가 식이라서 대입한 값이 결괏값으로 출력되지만, let이 앞에 붙는 순간 선언문이 된다.
    - 문(statement)은 식과 다르게 결괏값이 없고 식의 자리에 사용할 수 없다.
    - undefined나 null을 넣으면 변수에 넣은 값을 비울 수 있다.
    - 변수에 다른 변수를 대입할 수도 있다.

### 상수

- const: 상수(constant)의 줄임말이다.
- 상수는 변하지 않는 수이다.
- 선언한 것을 바꿀 수 없다.
- var: let이랑 비슷하지만 let과 다르게 계속 다시 선언할 수 있다.

### 조건문

- 주어진 조건에 따라 코드를 실행하거나 실행하지 않는 문이다.(ex: 로그인 여부)
- 조건식과 동작문으로 구분된다.

```jsx
if (조건식) {
동작문1
동작문2
동작문3
}
```

- 조건식이 참인 값이면 내부의 동작문이 실행되고, 거짓인 값이면 동작문이 실행되지 않는다.

```jsx
if (true) {
console.log('Hello, world');
}
```

```jsx
let condition = true;
if (condition) {
console.log('Hello, world')
}
```

- if문 뒤에 else if문을 적고, 그 뒤에 else if 문에 해당하는 조건식과 동작문을 추가한다.
- else if 문과 else문은 꼭 나와야하는 건 아니지만 if문이 처음에 나와야지만 사용할 수 있다.
- else if문이나 else문은 단독으로 사용할 수 없다.

```jsx
const score = 90;
  if (score >= 90) {
    console.log('A+');
}   else if (score < 90 && score >= 80){
    console.log('A');
}   else if (score >= 70){
    console.log('B+');
}
```

- switch문
    - 조건식 2개가 사용된다.
    - switch 옆 소괄호 조건식의 값이 case의 비교 조건식 값과 일치(==)하면 해당 동작문이 실행된다.
    - 보통 조건식에 변수를 넣고, 비교 조건식에는 변수와 비교할 값을 넣는다.
    
    ```jsx
    switch (조건식) {
    case 비교조건식;
       동작문
    }
    ```
    
    - break를 작성하면 일치하는 식만 작동된다.
    - default는 일치하는 식이 없을 때 작동된다.
    
    ```jsx
    let value = 'B';
      switch (value) {
        case 'A':
          console.log('A');
          break;
        case 'B':
          console.log('B');
          break;
        case 'C':
          console.log('C');
          break;
        default:
          console.log('일치하지않는다.');
          break;
    }
    ```
    

### 조건부 연산자(삼항 연산)

- if 문과 switch 문 외에 분기 처리에 사용하는 식이다.
- 기본 형식
    - `조건식 ? 참일 때 실행되는 식 : 거짓일 때 실행되는 식`
    
    ```jsx
    let condition = true;
    let value = condition ? '참' : '거짓';
    console.log(value);
    ```
    

### 반복문

- while
    - 조건식이 참인 동안 반복해서 동작문을 실행한다.
    
    ```jsx
    let i = 1;
    while (i <= 100) {
      console.log('Hello, world');
      i++
    }
    ```
    
    - `i = i + 1`  `i += 1`  `i++` 를 두고 실행하면 i가 101이 될 때 조건식이 false가 되어 반복문이 멈춘다.
- for
    - for 문 소괄호에는 시작과 조건식, 종료식이 들어간다.
    - 조건식과 동작문은 while문과 같다.
    - 시작 조건문 동작문 종료식 조건문 동작문 종료식이 반복된다.
    - 시작, 조건식, 종료식은 생략할 수 있다.
    
    ```jsx
    for (시작; 조건문; 종료식) {
        동작문;
    }
    for (let i = 0; i < 100; i++) {
        console.log('Hello, world');
    }
    ```
    

### break

```jsx
let i = 0;
while (true) {
  if (i === 5) break;
}
console.log(i);
```

- break가 있기 때문에 i가 5가 되면 반복문은 종료된다.

### continue

- 반복문이 특정 조건에서만 실행되기 원할 때 사용한다.
- continue문을 넣으면 이후 코드는 건너뛰게 된다.

```jsx
let i = 0;
while (i < 10) {
  i++;
  if (i % 2 === 0) {
    continue;
  }
  console.log(i);
}
```

- 홀수만 출력된다.

### 중첩된 반복

- 반복문 안에 반복문이 들어있는 것이다.

```jsx
for (let i - 0; i < 10; i ++) {
  for (let j =0; j < 10; j++) {
    console.log(i, j);
  }
 }
```

- (0,0)에서 (9,9)까지 실행된다.
- 중첩 횟수가 증가할수록 코드가 점점 어려워진다.

### 객체(object)

- 자료형의 일종으로 다양한 값을 모아둔 또다른 값이다.
- 배열(array)
    - 다양한 값을 나열하는 경우이다.
    - 배열 이름 뒤에 .length를 붙이면 배열의 요소의 수를 알 수 있다.
    
    ```jsx
    const fruits = ['사과', '오렌지', '배', '딸기'];
    console.log(fruits[0]);
    console.log(fruits[1]);
    console.log(fruits[2]);
    console.log(fruits[3]);
    console.log(fruits.length);
    ```
    
    - 배열을 만든 후, 중간에 배열을 추가할 수 있다.
    - .unshift를 이용해서 제일 앞에 배열을 추가할 수 있다.
    - .push를 이용해서 마지막에 배열을 추가할 수 있다.
    
    ```jsx
    const target = ['a', 'b', 'c', 'd', 'e'];
    target[5] = 'f';
    console.log(target); //["a", "b", "c", "d", "e", "f"]
    
    const target = ['a', 'b', 'c', 'd', 'e'];
    target[target.length] = 'f';
    console.log(target); //["a", "b", "c", "d", "e", "f"]
    
    const target = ['a', 'b', 'c', 'd', 'e'];
    target.unshift(1);
    console.log(target); //["1", "a", "b", "c", "d", "e"]
    
    const target = ['a', 'b', 'c', 'd', 'e'];
    target.push(f);
    console.log(target); //["a", "b", "c", "d", "e", "f"]
    ```
    
    - 배열을 만든 후, 중간에 배열을 수정할 수 있다.
    
    ```jsx
    const target = ['a', 'b', 'c', 'd', 'e'];
    target[2] = 'f';
    console.log(target); //["a", "b", "f", "d", "e"]
    ```
    
    - 배열을 만든 후, 중간에 배열을 제거할 수 있다.
    - .pop을 이용해서 마지막 배열을 제거할 수 있다.
    - .shift를 이용해서 제일 앞 배열을 제거할 수 있다.
    - .splice를 이용해서 원하는 자리부터 n개의 배열을 제거할 수 있다.
    
    ```jsx
    const target = ['a', 'b', 'c', 'd', 'e'];
    target.pop();
    console.log(target); //["a", "b", "c", "d"]
    
    const target = ['a', 'b', 'c', 'd', 'e'];
    target.shift();
    console.log(target); //["b", "c", "d", "e"]
    
    const target = ['a', 'b', 'c', 'd', 'e'];
    target.splice(1, 2);
    console.log(target); //["a", "d", "e"]
    
    const target = ['a', 'b', 'c', 'd', 'e'];
    target.splice(1);
    console.log(target); //["a"]
    
    const target = ['a', 'b', 'c', 'd', 'e'];
    target.splice(1, 2, 'f', 'g');
    console.log(target); //["a", "f", "g", "d", "e"]
    ```
    
    - 배열에 특정 요소가 있는지 찾아볼 수 있다.
    - 일종의 검색 기능이다.
    - .includes는 true와 false로 판단된다.
    - .indexOf와 .lastIndexOf를 사용해 배열이 어느 위치에 있는지 알 수 있다.
    
    ```jsx
    const target = ['a', 'b', 'c', 'd', 'e'];
    const result = target.includes('c');
    const result2 = target.includes('f');
    console.log(result); //true
    console.log(result2); //false
    
    const target = ['d', 'b', 'c', 'd', 'e'];
    const result = target.indexOf('c');
    const result2 = target.lastIndexOf('b');
    const result3 = target.indexOf('a');
    console.log(result); //2
    console.log(result2); //3
    console.log(result3); //-1
    ```
    
    - 배열은 while문이나 for문 모두 사용할 수 있다.
    
    ```jsx
    const target = ['a', 'b', 'c', 'd', 'e'];
    let i = 0;
    while (i < target.length) {
      console.log(target[i]);
      i++;
    }
    
    const target = ['a', 'b', 'c', 'd', 'e'];
    for (let i = 0; i < target.length; i++) {
      console.log(target[i]);
    }
    ```
    
- 함수
    - 일정한 동작을 수행하는 코드를 의미한다.
    - 함수를 미리 만들어두고 원할 때 실행해 정해진 동작을 수행하게 할 수 있다.
    - `function` 예약어를 사용하거나 `=>` 기호를 사용한다.
    
    ```jsx
    function a() {} //함수 선언문
    const b = function() {}; //함수 표현식
    const c = () => {}; //화살표 함
    ```
    
    ```jsx
    function a() {
      console.log ('hellow');
      console.log ('world');
    } //선언
    a(); //호출
    ```
    
    - return을 이용하여 반환겂을 직접 정할 수 도 있다.
    - parameter: 매개변수
    - argument: 인수
    
    ```jsx
    function minus1(x, y){
      const a = 100;
      return (x - y) * a;
    }
    console.log(minus1(5,3));
    ```
    
- 객체 리터럴
    - 객체는 여러 개의 변수를 하나의 변수로 묶을 때 사용한다.
    
    ```jsx
    const alphabet = {
      1: a,
      2: b,
      3: c,
    }
    ```
    
    - 객체 속성을 수정할 때는 `alphabet.1 = 'd'; console.log(alphabet.1);` 으로 고쳐준다.
    - 객체 속성을 제거할 때는 앞에 `delete` 를 붙여준다.
- 배열과 함수가 객체인 이유는 객체의 성질을 모두 다 사용할 수 있기 때문이다.
- 배열과 함수에도 속성들을 추가할 수도 있고 수정 및 제거할 수도 있다.
- 객체는 함수의 배열을 포함하는 개념이라서 `{}`를 사용해 만든 객체를 객체 리터럴이라고 따로 부른다.
- 함수와 배열은 주로 객체 리터럴과는 다른 목적으로 사용하기에 함수와 배열에 임의의 속성을 넣는 경우는 거의 없다.
- 메서드
    - 속성 값으로 자바스크립트의 모든 값을 넣을 수 있다.
    - 객체의 속성 값으로 함수를 넣었을 때를 말한다.
    - `log`는 `debug` 객체의 메서드이다. `debug.log`
    - `console` 객체와 그 안에 든 `log` 메서드는 웹 브라우저가 기본으로 만들어둔 객체이므로 따로 선언하지 않아도 사용할 수 있다.
- 객체간 비교
    - 객체끼리 비교를 하면 항상 `false` 가 나온다.
    - 객체를 저장해 놓고 비교해야한다.
- 참조와 복사
    
    ```jsx
    const a = { name: 'abc' };
    const b = a;
    a.name = 'def';
    console.log(b.name); // 'def'
    ```
    
    - a 변수의 name 속성 값을 변경하면 b의 속성 값도 변경된다.
    - 객체를 저장한 변수를 다른 변수에 대입하면 두 변수 모두 같은 객체를 저장하는 셈이된다.
    - 이런 상황을 변수 a와 b가 같은 객체를 참조하고 잇다고 한다.
    
    ```jsx
    let a = { name: 'abc' };
    let b = a;
    a = 'def';
    console.log(b); // 'abc'
    ```
    
    - 변수 b에 a를 대입하고 a를 바꿨는데도 b는 영향을 받지 않는다.
    - 객체가 아닌 값을 변수에 저장한 경우에는 참조 관계가 생기지 않는다.
    - 참조가 생기지 않는 상황을 복사라고 부른다.

### prompt

- 사용자로부터 값을 전달받는다.

### alert

- 사용자에게 경고 메세지를 표시한다.

### confirm

- 사용자의 확인을 요구한다.

### HTML 태그 선택하기

```jsx
const 선택자 = document.querySelector('선택자')
console.log(선택자);
```

- 선택자는  HTML 태그를 선택할 수 있게 도와주는 문자열이다.
- `querySelectorAll`은 모두 다 선택하는 것이다.
- `id`를 선택할 때는 `#`을 붙인다.
- `class`는 `.`을 붙인다.

```jsx
const 선택자 = document.querySelector(div span)
console.log(선택자);

const 선택자 = document.querySelector(div>span)
console.log(선택자);
```

- 자손 태그와 자식 태그를 찾을 때 사용한다.

### 콜백함수

```jsx
document.querySelector('input').addEventListener('input' , function(){
  console.log('글자 입력')
});

const onClick = function() {
  console.log('버튼 클릭');
}
document.querySelector('button').addEventListener('click', on Click);
```

- 자바 스크립트가 사용자가 어떤 동작을 했는지 알아챌 수 있다.
- 다른 함수의 인자로써 이용되는 함수이다.
- 어떤 이벤트에 의해 호출되어지는 함수이다.

### 이벤트 추가 조사

- 마우스 이벤트
    - click: 요소에 마우스를 클릭했을 때 이벤트가 발생한다.
    - dbclick: 요소에 마우스를 더블 클릭했을 때 이벤트가 발생한다.
    - mouseover: 요소에 마우스를 오버했을 때 이벤트가 발생한다.
    - mouseout: 요소에 마우스를 아웃했을 때 이벤트가 발생한다.
    - mousedown: 요소에 마우스를 눌렀을 때 이벤트가 발생한다.
    - mouseup: 요소에 마우스를 떼었을 때 이벤트가 발생한다.
    - mousemove: 요소에 마우스를 움직였을 때 이벤트가 발생한다.
    - contextmenu: context menu가 나오기 전에 이벤트가 발생한다.
- 키 이벤트
    - keydown: 키를 눌렀을 때 이벤트가 발생한다.
    - keyup: 키를 떼었을 때 이벤트가 발생한다.
    - keypress: 키를 누른 상태에서 이벤트가 발생한다.
- 폼 이벤트
    - focus: 요소에 포커스가 이동되었을 때 이벤트가 발생한다.
    - blur: 요소에 포커스가 벗어났을 때 이벤트가 발생한다.
    - change: 요소에 값이 변경되었을 때 이벤트가 발생한다.
    - submit: submit 버튼을 눌렀을 때 이벤트가 발생한다.
    - reset: reset 버튼을 눌렀을 때 이벤트가 발생한다.
    - select: input이나 textarea 요소 안의 텍스트를 드래그하여 선택했을 때 이벤트가 발생한다.
- 로드 및 기타 이벤트
    - load: 페이지의 로딩이 완료되었을 때 이벤트가 발생한다.
    - abort: 이미지의 로딩이 중단되었을 때 이벤트가 발생한다.
    - unload: 페이지가 다른 곳으로 이동될 때 이벤트가 발생한다.
    - resize: 요소에 사이즈가 변경되었을 때 이벤트가 발생한다.
    - scroll: 스크롤바를 움직였을 때 이벤트가 발생한다.

### 이벤트 연결

- 인라인 방식
    - `<태그명 on이벤트 = 자바스크립트 코드> </태그명>`
    
    ```jsx
    <div onClick="alert('클릭했습니다1')">클릭</div>
    <div onClick="view()">클릭</div>
    
    <script>
      function view(){
        alert("클릭했습니다2");
    }
    </script>
    ```
    
- 고전 방식
    - `객체.on이벤트명 = function(){}`
    - `function 함수명(){}객체.on이벤트명=함수명`
    
    ```jsx
    <div id = "bt">클릭</div>
    
    //방법1
    <script>
      var bt = document.getElementById("bt");
      bt.onClick = function (){
        alert("클릭했습니다.");
      };
    </script>
    
    //방법2
    <script>
      var bt = document.getElementById("bt");
      function view() {
        alert("클릭했습니다!!!");
      }
    
    bt.onclick = view;
    
    /*
    bt.onclick = function() {
      view();
    }
    */
    </script>
    ```
    
    - `<script></script>` 를 `<head>`태그 내부에 작성할 경우
        - onload는 문서가 모두 로드되었을 때를 의미한다.
        - onload 이벤트가 실행되면 onload의 익명함수 부분은 일단 미실행한다.
        - 문서의 끝까지 모두 로드되었을 때 익명함수를 실행한다.
            - `<div id="bt">클릭</div>` 요소보다 `document.getElementById("bt")`가 먼저 정의 되었기 때문에 onload이벤트를 사용한다.
            - onload 이벤트 미사용시 `document.getElementById("bt")`가 실행되는 시점에 `<div id="bt">클릭</div>` 요소는 미존재 하므로 bt 변수에 저장되지 않는 문제가 발생한다.
        - 자바스크립트가 `<head>`태그 안에서 정의되고 `getElementById()` 메서드가 사용될 때는 반드시 onload 이벤트를 사용한다.
    
    ```jsx
    <!DOCTYPE html>
    <html lang="ko">
      <head>
        <meta charset="UTF-8">
        <title>이벤트</title>
        <style>
          div{
            border : 1px solid red;
          }
        </style>
        <script>
          window.onload = function () {
            var bt = document.getElementById("bt");
            bt.onClick = function () {
              alert("클릭했습니다.");
            };
          };
        </script>
      </head>
      <body>
        <div id="bt">클릭</div>
      </body>
    </html>
    ```
    
- DOM
    - 자바스크립트와 HTML+CSS를 연결해주는 것이 DOM이다.
    - Document Object Model의 약자이다.
    - 모든 HTML 태그는 document라는 자바 스크립트 object 안에 저장되어있다.
    - 자바스크립트에서 HTML을 object로 불러올 수 있다.
    - 자바스크립트에서 HTML과 CSS를 연결하여 실행하려면, element를 Select하고 manipulate한다.