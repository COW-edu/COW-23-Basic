# week4

### 세미콜론

- 하나의 명령이 끝날 때 세미콜론을 붙이기를 권장한다.

```js
console.loge('hello, world');
```

### 주석

- 사람만 알아볼 수 있도록 설명을 작성하는 부분이다.
- 코드에 대한 자세한 설명을 작성하거나 특정 코드를 임시로 사용하지 않도록 만들 때 사용한다.

```js
//주석-설명을 작성한다.
/*주석-설명을 작성한다.*/
```

### 자료형

- 값(value)은 프로그램이 조작할 수 있는 데이터를 의미한다.
- 값에는 여러 가지 종류가 있으며 이런 값의 종류를 자료형(data type)이라고 한다.
- 문자열(string)
    - 프로그래밍에서 하나의 글자를 문자라고 하는데 문자들이 하나 이상 나열되어 있으면 문자열이라고 한다.
    - 따옴표(””, ‘’), 백틱(`)로 감싸줘야 한다.
    - `는 문자열에서 줄바꿈을 할 수 있다.
    - \n을 사용하면 줄바꿈을 사용할 수 있다.
    - `typeof ‘문자열’` 로도 작성이 가능하다.
    - 사용하고 싶은 따옴표랑 다른 따옴표로 감싸주면 출력된다.
    - 같은 따옴표를 사용하고 싶다면 `‘how\'re you'`로 입력하면 된다.
    - `문자열\\입력` 시 `문자열\입력` 으로 출력된다.
    - 문자열끼리 더하기가 가능하다.
- 숫자
    - 사칙연산이 가능하다.
    - 모든 진법 작성이 가능하다.
    - `5e-4` 는 `0.0005`로 출력된다.
    - `5e4`는 `50000`으로 출력된다.
    - NaN=not a number
    - `“1234”` 는 문자열이고 `1234`는 숫자다.
    - `parseInt()` : 정수를 반환한다. “4월”이라 입력시 4만 출력된다.
    - `Number()` : 숫자만 읽는다. “4월”이라고 입력시 출력되지 않는다.
    - `pronpt()` : 입력한 값이 나온다.
    - `parseInt(prompt())` : 입력한 값의 정수가 나온다.
    - `typeof parseInt(prompt())` : 입력한 값이 무엇인지 알려준다. 54를 입력시 number가 출력된다.
    - 연산자 우선 순위: ()사용시 1순위가 된다.
- 불 값
    - true와 false를 나타내는 boolean이라는 자료형이 있다.
    - `==` `>` `<` `<=` `>=` `!=`
    - 특수문자 비교시 `.charCodeAT()`를 상용한다.
    - NaN은 어떤한 값이랑 비교를 해도 false가 나온다.
    - `==` 와 `===`의 차이: `===`을 사용하면 값 비교 뿐만 아니라 자료형까지 비교한다.

### 논리 연산자

- `||` :또는, 그리고
- `flase`, `‘’`(빈 문자열), `0`, `NaN`, `undefined`, `nul`l은 불 값으로 형 변환했을 대 flase가 된다.(`document.all` 또한 false이지만 잘 사용되지 않는다.)
- 나머지는 ture이다.
- `!` 는 반대이고 `!!` 는 다시 참이된다.

### undefined, null

- undefined: 반환해줄 값이 없다.
- undefined==null ture
- undefined===null flase
- typeof null
    - 결과값이 “null”이 아니라 “object”이다.
    - 값이 null인지 확인하기 위해서는 === null을 사용해야한다.
- null과 undefined는 둘 다 빈 값이다.
- undefined는 기본값이라는 의미라도 있지만 null은 역할이 없다는 차이점이 있다.

### 변수

- 프로그램을 만들 때는 잠깐 동안 특정한 값을 저장해야 하는 상황이 자주 발생하는데 이때 사용하는 것이 변수이다.

```js
let string = 1234;
```

- 선언문: let으로 시작하는 명령이다.
- string 자리는 변수명이다.
- 초기화: 변수를 선언함과 동시에 값을 대입하는 행위이다.
- 변수의 이름과 값은 컴퓨터의 메모리에 저장된다.
- 변수명 짓기
    - 한글, 한자, 영어 다 사용가능하다.
    - 숫자를 사용할 때는 제일 처음에 나오면 안된다.
    - 대문자도 가능하다.
    - 특수문자는 $_가 주로 가능하다.
    - let, class, const 등의 예약어는 변수명으로 사용이 불가능하다.(let은 예약어가 아니다.)
- 변수 수정하기
    - 변수 수정시 let은 다시 작성하면 안된다.
    
    ```js
    let change = '바꾼다.';
    change = '바꿨다.';
    ```
    
    - let으로 변수를 선언할 때는 콘솔의 결괏값이 undefined이지만, 변수의 값을 바꿀 때는 결괏값이 바꾼 값이 된다.
    - let이 없을 때는 코드가 식이라서 대입한 값이 결괏값으로 출력되지만, let이 앞에 붙는 순간 선언문이 된다.
    - 문(statement)은 식과 다르게 결괏값이 없고 식의 자리에 사용할 수 없다.
    - undefined나 null을 넣으면 변수에 넣은 값을 비울 수 있다.
    - 변수에 다른 변수를 대입할 수도 있다.

### 상수

- const: 상수(constant)의 줄임말이다.
- 상수는 변하지 않는 수이다.
- 선언한 것을 바꿀 수 없다.
- var: let이랑 비슷하지만 let과 다르게 계속 다시 선언할 수 있다.

### 조건문

- 주어진 조건에 따라 코드를 실행하거나 실행하지 않는 문이다.(ex: 로그인 여부)
- 조건식과 동작문으로 구분된다.

```js
if (조건식) {
동작문1
동작문2
동작문3
}
```

- 조건식이 참인 값이면 내부의 동작문이 실행되고, 거짓인 값이면 동작문이 실행되지 않는다.

```js
if (true) {
console.log('Hello, world');
}
```

```js
let condition = true;
if (condition) {
console.log('Hello, world')
}
```

- if문 뒤에 else if문을 적고, 그 뒤에 else if 문에 해당하는 조건식과 동작문을 추가한다.
- else if 문과 else문은 꼭 나와야하는 건 아니지만 if문이 처음에 나와야지만 사용할 수 있다.
- else if문이나 else문은 단독으로 사용할 수 없다.

```js
const score = 90;
  if (score >= 90) {
    console.log('A+');
}   else if (score < 90 && score >= 80){
    console.log('A');
}   else if (score >= 70){
    console.log('B+');
}
```

- switch문
    - 조건식 2개가 사용된다.
    - switch 옆 소괄호 조건식의 값이 case의 비교 조건식 값과 일치(==)하면 해당 동작문이 실행된다.
    - 보통 조건식에 변수를 넣고, 비교 조건식에는 변수와 비교할 값을 넣는다.
    
    ```js
    switch (조건식) {
    case 비교조건식;
       동작문
    }
    ```
    
    - break를 작성하면 일치하는 식만 작동된다.
    - default는 일치하는 식이 없을 때 작동된다.
    
    ```js
    let value = 'B';
      switch (value) {
        case 'A':
          console.log('A');
          break;
        case 'B':
          console.log('B');
          break;
        case 'C':
          console.log('C');
          break;
        default:
          console.log('일치하지않는다.');
          break;
    }
    ```
    

### 조건부 연산자(삼항 연산)

- if 문과 switch 문 외에 분기 처리에 사용하는 식이다.
- 기본 형식
    - `조건식 ? 참일 때 실행되는 식 : 거짓일 때 실행되는 식`
    
    ```js
    let condition = true;
    let value = condition ? '참' : '거짓';
    console.log(value);
    ```
    

### 반복문

- while
    - 조건식이 참인 동안 반복해서 동작문을 실행한다.
    
    ```js
    let i = 1;
    while (i <= 100) {
      console.log('Hello, world');
      i++
    }
    ```
    
    - `i = i + 1`  `i += 1`  `i++` 를 두고 실행하면 i가 101이 될 때 조건식이 false가 되어 반복문이 멈춘다.
- for
    - for 문 소괄호에는 시작과 조건식, 종료식이 들어간다.
    - 조건식과 동작문은 while문과 같다.
    - 시작 조건문 동작문 종료식 조건문 동작문 종료식이 반복된다.
    - 시작, 조건식, 종료식은 생략할 수 있다.
    
    ```js
    for (시작; 조건문; 종료식) {
        동작문;
    }
    for (let i = 0; i < 100; i++) {
        console.log('Hello, world');
    }
    ```
    

### break

```js
let i = 0;
while (true) {
  if (i === 5) break;
}
console.log(i);
```

- break가 있기 때문에 i가 5가 되면 반복문은 종료된다.

### continue

- 반복문이 특정 조건에서만 실행되기 원할 때 사용한다.
- continue문을 넣으면 이후 코드는 건너뛰게 된다.

```js
let i = 0;
while (i < 10) {
  i++;
  if (i % 2 === 0) {
    continue;
  }
  console.log(i);
}
```

- 홀수만 출력된다.

### 중첩된 반복

- 반복문 안에 반복문이 들어있는 것이다.

```js
for (let i - 0; i < 10; i ++) {
  for (let j =0; j < 10; j++) {
    console.log(i, j);
  }
 }
```

- (0,0)에서 (9,9)까지 실행된다.
- 중첩 횟수가 증가할수록 코드가 점점 어려워진다.

### 객체(object)

- 자료형의 일종으로 다양한 값을 모아둔 또다른 값이다.
- 배열(array)
    - 다양한 값을 나열하는 경우이다.
    - 배열 이름 뒤에 .length를 붙이면 배열의 요소의 수를 알 수 있다.
    
    ```js
    const fruits = ['사과', '오렌지', '배', '딸기'];
    console.log(fruits[0]);
    console.log(fruits[1]);
    console.log(fruits[2]);
    console.log(fruits[3]);
    console.log(fruits.length);
    ```
    
    - 배열을 만든 후, 중간에 배열을 추가할 수 있다.
    - .unshift를 이용해서 제일 앞에 배열을 추가할 수 있다.
    - .push를 이용해서 마지막에 배열을 추가할 수 있다.
    
    ```js
    const target = ['a', 'b', 'c', 'd', 'e'];
    target[5] = 'f';
    console.log(target); //["a", "b", "c", "d", "e", "f"]
    
    const target = ['a', 'b', 'c', 'd', 'e'];
    target[target.length] = 'f';
    console.log(target); //["a", "b", "c", "d", "e", "f"]
    
    const target = ['a', 'b', 'c', 'd', 'e'];
    target.unshift(1);
    console.log(target); //["1", "a", "b", "c", "d", "e"]
    
    const target = ['a', 'b', 'c', 'd', 'e'];
    target.push(f);
    console.log(target); //["a", "b", "c", "d", "e", "f"]
    ```
    
    - 배열을 만든 후, 중간에 배열을 수정할 수 있다.
    
    ```js
    const target = ['a', 'b', 'c', 'd', 'e'];
    target[2] = 'f';
    console.log(target); //["a", "b", "f", "d", "e"]
    ```
    
    - 배열을 만든 후, 중간에 배열을 제거할 수 있다.
    - .pop을 이용해서 마지막 배열을 제거할 수 있다.
    - .shift를 이용해서 제일 앞 배열을 제거할 수 있다.
    - .splice를 이용해서 원하는 자리부터 n개의 배열을 제거할 수 있다.
    
    ```js
    const target = ['a', 'b', 'c', 'd', 'e'];
    target.pop();
    console.log(target); //["a", "b", "c", "d"]
    
    const target = ['a', 'b', 'c', 'd', 'e'];
    target.shift();
    console.log(target); //["b", "c", "d", "e"]
    
    const target = ['a', 'b', 'c', 'd', 'e'];
    target.splice(1, 2);
    console.log(target); //["a", "d", "e"]
    
    const target = ['a', 'b', 'c', 'd', 'e'];
    target.splice(1);
    console.log(target); //["a"]
    
    const target = ['a', 'b', 'c', 'd', 'e'];
    target.splice(1, 2, 'f', 'g');
    console.log(target); //["a", "f", "g", "d", "e"]
    ```
    
    - 배열에 특정 요소가 있는지 찾아볼 수 있다.
    - 일종의 검색 기능이다.
    - .includes는 true와 false로 판단된다.
    - .indexOf와 .lastIndexOf를 사용해 배열이 어느 위치에 있는지 알 수 있다.
    
    ```js
    const target = ['a', 'b', 'c', 'd', 'e'];
    const result = target.includes('c');
    const result2 = target.includes('f');
    console.log(result); //true
    console.log(result2); //false
    
    const target = ['d', 'b', 'c', 'd', 'e'];
    const result = target.indexOf('c');
    const result2 = target.lastIndexOf('b');
    const result3 = target.indexOf('a');
    console.log(result); //2
    console.log(result2); //3
    console.log(result3); //-1
    ```
    
    - 배열은 while문이나 for문 모두 사용할 수 있다.
    
    ```js
    const target = ['a', 'b', 'c', 'd', 'e'];
    let i = 0;
    while (i < target.length) {
      console.log(target[i]);
      i++;
    }
    
    const target = ['a', 'b', 'c', 'd', 'e'];
    for (let i = 0; i < target.length; i++) {
      console.log(target[i]);
    }
    ```
    
- 함수
    - 일정한 동작을 수행하는 코드를 의미한다.
    - 함수를 미리 만들어두고 원할 때 실행해 정해진 동작을 수행하게 할 수 있다.
    - `function` 예약어를 사용하거나 `=>` 기호를 사용한다.
    
    ```js
    function a() {} //함수 선언문
    const b = function() {}; //함수 표현식
    const c = () => {}; //화살표 함
    ```
    
    ```js
    function a() {
      console.log ('hellow');
      console.log ('world');
    } //선언
    a(); //호출
    ```
    
    - return을 이용하여 반환겂을 직접 정할 수 도 있다.
    - parameter: 매개변수
    - argument: 인수
    
    ```js
    function minus1(x, y){
      const a = 100;
      return (x - y) * a;
    }
    console.log(minus1(5,3));
    ```
    
- 객체 리터럴
    - 객체는 여러 개의 변수를 하나의 변수로 묶을 때 사용한다.
    
    ```js
    const alphabet = {
      1: a,
      2: b,
      3: c,
    }
    ```
    
    - 객체 속성을 수정할 때는 `alphabet.1 = 'd'; console.log(alphabet.1);` 으로 고쳐준다.
    - 객체 속성을 제거할 때는 앞에 `delete` 를 붙여준다.
- 배열과 함수가 객체인 이유는 객체의 성질을 모두 다 사용할 수 있기 때문이다.
- 배열과 함수에도 속성들을 추가할 수도 있고 수정 및 제거할 수도 있다.
- 객체는 함수의 배열을 포함하는 개념이라서 `{}`를 사용해 만든 객체를 객체 리터럴이라고 따로 부른다.
- 함수와 배열은 주로 객체 리터럴과는 다른 목적으로 사용하기에 함수와 배열에 임의의 속성을 넣는 경우는 거의 없다.
- 메서드
    - 속성 값으로 자바스크립트의 모든 값을 넣을 수 있다.
    - 객체의 속성 값으로 함수를 넣었을 때를 말한다.
    - `log`는 `debug` 객체의 메서드이다. `debug.log`
    - `console` 객체와 그 안에 든 `log` 메서드는 웹 브라우저가 기본으로 만들어둔 객체이므로 따로 선언하지 않아도 사용할 수 있다.
- 객체간 비교
    - 객체끼리 비교를 하면 항상 `false` 가 나온다.
    - 객체를 저장해 놓고 비교해야한다.
- 참조와 복사
    
    ```js
    const a = { name: 'abc' };
    const b = a;
    a.name = 'def';
    console.log(b.name); // 'def'
    ```
    
    - a 변수의 name 속성 값을 변경하면 b의 속성 값도 변경된다.
    - 객체를 저장한 변수를 다른 변수에 대입하면 두 변수 모두 같은 객체를 저장하는 셈이된다.
    - 이런 상황을 변수 a와 b가 같은 객체를 참조하고 잇다고 한다.
    
    ```js
    let a = { name: 'abc' };
    let b = a;
    a = 'def';
    console.log(b); // 'abc'
    ```
    
    - 변수 b에 a를 대입하고 a를 바꿨는데도 b는 영향을 받지 않는다.
    - 객체가 아닌 값을 변수에 저장한 경우에는 참조 관계가 생기지 않는다.
    - 참조가 생기지 않는 상황을 복사라고 부른다.

### prompt

- 사용자로부터 값을 전달받는다.

### alert

- 사용자에게 경고 메세지를 표시한다.

### confirm

- 사용자의 확인을 요구한다.

### HTML 태그 선택하기

```js
const 선택자 = document.querySelector('선택자')
console.log(선택자);
```

- 선택자는  HTML 태그를 선택할 수 있게 도와주는 문자열이다.
- `querySelectorAll`은 모두 다 선택하는 것이다.
- `id`를 선택할 때는 `#`을 붙인다.
- `class`는 `.`을 붙인다.

```js
const 선택자 = document.querySelector(div span)
console.log(선택자);

const 선택자 = document.querySelector(div>span)
console.log(선택자);
```

- 자손 태그와 자식 태그를 찾을 때 사용한다.

### 콜백함수

```js
document.querySelector('input').addEventListener('input' , function(){
  console.log('글자 입력')
});

const onClick = function() {
  console.log('버튼 클릭');
}
document.querySelector('button').addEventListener('click', on Click);
```

- 자바 스크립트가 사용자가 어떤 동작을 했는지 알아챌 수 있다.
- 다른 함수의 인자로써 이용되는 함수이다.
- 어떤 이벤트에 의해 호출되어지는 함수이다.

### 이벤트 추가 조사

- 마우스 이벤트
    - click: 요소에 마우스를 클릭했을 때 이벤트가 발생한다.
    - dbclick: 요소에 마우스를 더블 클릭했을 때 이벤트가 발생한다.
    - mouseover: 요소에 마우스를 오버했을 때 이벤트가 발생한다.
    - mouseout: 요소에 마우스를 아웃했을 때 이벤트가 발생한다.
    - mousedown: 요소에 마우스를 눌렀을 때 이벤트가 발생한다.
    - mouseup: 요소에 마우스를 떼었을 때 이벤트가 발생한다.
    - mousemove: 요소에 마우스를 움직였을 때 이벤트가 발생한다.
    - contextmenu: context menu가 나오기 전에 이벤트가 발생한다.
- 키 이벤트
    - keydown: 키를 눌렀을 때 이벤트가 발생한다.
    - keyup: 키를 떼었을 때 이벤트가 발생한다.
    - keypress: 키를 누른 상태에서 이벤트가 발생한다.
- 폼 이벤트
    - focus: 요소에 포커스가 이동되었을 때 이벤트가 발생한다.
    - blur: 요소에 포커스가 벗어났을 때 이벤트가 발생한다.
    - change: 요소에 값이 변경되었을 때 이벤트가 발생한다.
    - submit: submit 버튼을 눌렀을 때 이벤트가 발생한다.
    - reset: reset 버튼을 눌렀을 때 이벤트가 발생한다.
    - select: input이나 textarea 요소 안의 텍스트를 드래그하여 선택했을 때 이벤트가 발생한다.
- 로드 및 기타 이벤트
    - load: 페이지의 로딩이 완료되었을 때 이벤트가 발생한다.
    - abort: 이미지의 로딩이 중단되었을 때 이벤트가 발생한다.
    - unload: 페이지가 다른 곳으로 이동될 때 이벤트가 발생한다.
    - resize: 요소에 사이즈가 변경되었을 때 이벤트가 발생한다.
    - scroll: 스크롤바를 움직였을 때 이벤트가 발생한다.

### 이벤트 연결

- 인라인 방식
    - `<태그명 on이벤트 = 자바스크립트 코드> </태그명>`
    
    ```js
    <div onClick="alert('클릭했습니다1')">클릭</div>
    <div onClick="view()">클릭</div>
    
    <script>
      function view(){
        alert("클릭했습니다2");
    }
    </script>
    ```
    
- 고전 방식
    - `객체.on이벤트명 = function(){}`
    - `function 함수명(){}객체.on이벤트명=함수명`
    
    ```js
    <div id = "bt">클릭</div>
    
    //방법1
    <script>
      var bt = document.getElementById("bt");
      bt.onClick = function (){
        alert("클릭했습니다.");
      };
    </script>
    
    //방법2
    <script>
      var bt = document.getElementById("bt");
      function view() {
        alert("클릭했습니다!!!");
      }
    
    bt.onclick = view;
    
    /*
    bt.onclick = function() {
      view();
    }
    */
    </script>
    ```
    
    - `<script></script>` 를 `<head>`태그 내부에 작성할 경우
        - onload는 문서가 모두 로드되었을 때를 의미한다.
        - onload 이벤트가 실행되면 onload의 익명함수 부분은 일단 미실행한다.
        - 문서의 끝까지 모두 로드되었을 때 익명함수를 실행한다.
            - `<div id="bt">클릭</div>` 요소보다 `document.getElementById("bt")`가 먼저 정의 되었기 때문에 onload이벤트를 사용한다.
            - onload 이벤트 미사용시 `document.getElementById("bt")`가 실행되는 시점에 `<div id="bt">클릭</div>` 요소는 미존재 하므로 bt 변수에 저장되지 않는 문제가 발생한다.
        - 자바스크립트가 `<head>`태그 안에서 정의되고 `getElementById()` 메서드가 사용될 때는 반드시 onload 이벤트를 사용한다.
    
    ```js
    <!DOCTYPE html>
    <html lang="ko">
      <head>
        <meta charset="UTF-8">
        <title>이벤트</title>
        <style>
          div{
            border : 1px solid red;
          }
        </style>
        <script>
          window.onload = function () {
            var bt = document.getElementById("bt");
            bt.onClick = function () {
              alert("클릭했습니다.");
            };
          };
        </script>
      </head>
      <body>
        <div id="bt">클릭</div>
      </body>
    </html>
    ```
    
- DOM
    - 자바스크립트와 HTML+CSS를 연결해주는 것이 DOM이다.
    - Document Object Model의 약자이다.
    - 모든 HTML 태그는 document라는 자바 스크립트 object 안에 저장되어있다.
    - 자바스크립트에서 HTML을 object로 불러올 수 있다.
    - 자바스크립트에서 HTML과 CSS를 연결하여 실행하려면, element를 Select하고 manipulate한다.

    ### 추가

- [ ]  multi line comment에 대한 내용을 추가해주세요
- 여러 줄에 걸쳐서 작성되는 문자열입니다. 템플릿 문자열이라고 합니다. 템플릿 문자열은  백틱(`)으로 문자열을 정의합니다. 기존 문자열 정의 방식처럼 큰 따옴표나 작은 따옴표로 문자열을 정의하지 않기 때문에 문자열에 큰 따옴표나 작은 따옴표가 있어도 영향을 받지 않습니다. ENTER를 눌러 줄바꿈을 할 수 있습니다. $[] 문법을 이용하여 문자열에 변수 또는 식을 넣을 수 있습니다.
- [ ]  문자열간의 사칙 연산(+, -, /, *)에 대한 동작 방식을 설명해주세요
- 문자열에는 더하기 외의 사칙 연산은 사용할 수 없습니다. 문자열끼리 더하는 경우, 두 문자열이 이어져 하나의 문자열이 생성됩니다. 문자열과 숫자, 또는 다른 자료형을 더하는 경우에도 자료형은 자동으로 문자열로 변환되어 문자열과 이어져 하나의 문자열이 생성됩니다.
- [ ]  "2.1", "2.4", "2.5", "2.9"를 parseInt()로 정수로 바꾸면 어떤 결과가 나오나요?
- parseInt() 함수는 문자열을 정수로 변환하는 함수입니다. 소수점 이하를 무시하고 정수만 반환합니다. 따라서 "2.1", "2.4", "2.5", "2.9"를 parseInt() 함수로 정수로 바꾸면 모두 2가 반환됩니다.
- [ ]  컴퓨터는 왜 소수점 계싼에서 미세한 오차가 발생하나요? 이를 해결하기 위해선 어떤 방법들이 있나요?
- 컴퓨터에서 소수점 계산에서 미세한 오차가 발생하는 이유는 컴퓨터가 이진수를 사용하기 때문입니다. 컴퓨터에서는 실수를 부동 소수점 방식으로 표현하는데, 부동 소수점 방식은 이진수로 소수를 표현하는 방법입니다. 이진수로는 2의 제곱수로 나타낼 수 있는 소수만 정확히 표현할 수 있으며, 그 이외의 소수는 근사치로 표현됩니다.
이를 해결하기 위해 소수점 이하를 정수로 바꾸거나 10진수를 사용하는 방법, 소수를 분수로 표현하는 방법, 소수를 더 큰 자리수로 표현하는 방법, 계산 순서를 변경하는 방법 등이 있습니다.
- [ ]  연산자의 우선순위에 대해서 작성해주세요
- 그룹연산자, 대괄호 연산자, 마침표 연산자증가 연산자, 감소 연산자, 단항 부정 연산자, NOT 연산자, delete 연산자, new 연산자, typeof 연산자나눗셈 연산자, 곱셈 연산자, 나머지 연산자덧셈 연산자, 뺄셈 연산자비교 연산자동등, 일치, 부등, 불일치AND 연산자OR 연산자삼항 연산자대입(할당) 연산자, 복합 대입 연산자멀티 연산자
순서로 우선순위가 결정됩니다.
- [ ]  변수 선언에 let 키워드를 이용하는 이유가 뭘까요?
- 변수명 중복이 불가능하고, 호이스팅 되지 않습니다. 그리고 스코프의 범위가 다르기 때문에 사용합니다.
let은 블록 스코프를 가집니다. 변수가 선언된 블록({}) 내에서만 유효하며, 블록 외부에서 선언된 변수는 블록 내에서는 사용할 수 없습니다. 이는 변수의 범위가 예측하기 쉽고, 의도하지 않은 변수 노출을 방지하는 데에 도움이 됩니다.
- [ ]  변수를 선언하지 않아도 제공하는 도구들은 뭐라고 부르나요?
- 전역 객체 또는 전역 변수라고 부릅니다. 전역 객체는 전역 범위에 항상 존재하는 객체를 의미합니다.
- [ ]  같은 변수 이름을 2번 선언하면 어떤 에러가 발생하나요? 항상 발생하나요?
- var 키워드로 선언한 변수명은 중복해서 생성할 수 있습니다.

```js
var num = 10 +20;
var num = 50;

```

- 컴퓨터 메모리에 num이라는 변수 공간을 생성하고 10 + 20 표현식의 평가 결과를 할당합니다. 그리고 num이라는 공간이 다시 생성되면서 기존에 할당된 데이터가 사라지고 50이라는 새로운 값이 할당됩니다. 자바스크립트에서는 오류가 아니라 아무런 경고가 발생하지 않습니다. 하지만 코드를 실행시키면 num 식별자가 이미 선언되었다는 오류 메시지가 발생합니다.
- [ ]  띄어쓰기 대신 대문자로 바꿔서 명명하는 변수 명명법을 무엇이라고 하나요? 그 외에 다른 방법은 무엇이 있니요?
- 띄어쓰기 대신 대문자로 바꾸어서 명명하는 변수 명명법은 카멜케이스(camel case)입니다. 다른 변수 명명법으로는 스네이크 케이스(snake case)와 케밥 케이스(kebab case)가 있습니다. 스네이크 케이스는 모든 단어를 소문자로 쓰고, 단어 사이를 (_)로 구분하는 방식입니다. 케밥 케이스는 모든 단어를 소문자로 쓰고 단어 사이를 (-)로 구분하는 방식입니다.
- [ ]  변수에 값을 넣는 행위를 뭐라고 부르나요?
- 할당(assignment)이라고 부릅니다.
- [ ]  js의 식(expression)과 문(statement)의 예시와 차이점에 대해서 작성해주세요
- 식은 값을 계산하여 반환하는 코드 블록입니다. 식은 값을 가지고 있습니다. 식은 변수, 상수, 연산자, 함수 호출 등과 같은 것일 수 있습니다.

```js
1 + 2 //3
"Hello, " + "world!" //"Hello, world"

```

- 문은 일련의 작업을 수행하고 결과를 반환하지 않는 코드 블록입니다. 문은 명령문으로 작동합니다.

```js
let x = 1; //변수를 선언하고 값을 할당하는 문
if (x > 0) {  //조건문을 실행하는 문
  console.log("x is positive"); //콘솔에서 메시지를 출력하는 문
}

```

- 식은 값으로 평가되므로 다른 식이나 문의 일부로 사용될 수 있지만, 문은 단독으로 사용됩니다. 또한 문은 일련의 작업을 수행하며 결과를 반환하지 않지만, 식은 값을 반환합니다.
- [ ]  let var의 공통점과 차이점에 대해서 작성해주세요
- 공통점은 변수를 선언하기 위해 사용되며 변수에 값을 할당할 수 있다는 것입니다. 또한 변수에 접근할 수 있다는 공통점을 가지고 있습니다. 차이점으로는 let은 블록 스코프를 가지지만, var은 함수 스코프를 가진다는 것입니다. 함수 스코프는 변수가 함수 내에서 선언된 경우 해당 함수 내에서만 접근할 수 있음을 의미합니다. 반면 블록 스코프는 변수가 블록 내에서만 선언된 경우 해당 블록 내에서만 접근할 수 있음을 의미합니다. let으로 선언된 변수는 동일한 이름의 변수를 다시 선언할 수 없지만 var로 선언된 변수는 같은 이름의 변수를 다시 선언할 수 있습니다. let은 호이스팅에 대해 안전하지만, var는 호이스팅으로 인해 예상치 못한 결과가 발생할 수 있습니다. 호이스팅은 변수 선언이 스코프의 맨 위로 이동되는 것을 의미합니다. 따라서 변수를 선언하기 전에 변수에 접근하려고 할 때 let은 참조 오류를 발생시킵니다. 하지만, var는 선언 전에 변수에 접근할 수 있고, 그 값은 undefined로 설정됩니다.
- [ ]  왜 var는 let과 다르게 같은 변수명으로 여러 번 선언할 수 있을까요?
- var는 함수 스코프를 가지기 때문에 함수 내에서 선언된 변수는 함수 내에서만 유효합니다. 따라서 동일한 변수 이름으로 여러번 선언해도 다른 함수에서 선언된 변수와 충돌하지 않습니다.
- [ ]  var가 잘 쓰이지 않는 이유는 뭘까요?
- var는 자바스크립트 초기부터 사용된 변수 선언 키워드입니다. 하지만 var는 함수 스코프를 가지기 때문에 함수 외부에서 선언된 변수도 전역 스코프에 존재하게 되어서 의도하지 않은 변수 덮어쓰기나 변수 호이스팅 등의 문제가 발생할 수 있습니다. let과 const 키워드가 도입되면서부터 var는 잘 사용되지 않고 있습니다. let은 블록 스코프를 가지기 때문에 변수 호이스팅이나 값 덮어쓰기 등의 문제를 방지할 수 있고, const는 값을 변경할 수 없는 상수를 선언할 때 사용됩니다. let과 const를 사용하면 더 안전하고 직관적인 코드를 작성할 수 있습니다.
- [ ]  중첩 조건문을 피하면 좋은 이유가 무엇일까요?
- 중첩 조건문을 사용하면 가독성이 떨어지고, 유지 보수성과 코드 재사용성이 떨어지기 때문에 피하는 것이 좋습니다. 중첩 조건문은 코드의 실행 경로가 복잡해져서 코드를 이해하기 어렵게 만듭니다. 여러 개의 중첩된 조건문이 있을 경우 코드의 논리를 파악하는 데 어려움을 겪을 수 있습니다. 코드의 복잡도가 증가하고, 코드의 유지 보수성이 떨어집니다. 중첩 조건문은 조건문 안에 또 다른 조건문을 작성하는 형태이기 때문에 코드가 복잡해지면서 오류가 발생할 가능성이 높아집니다. 중첩 조건문은 코드의 재사용성을 떨어뜨리는 원인이 됩니다. 중첩 조건문을 사용하면 코드의 실행 경로가 늘어나게 되므로, 코드를 다른 곳에서 재사용하거나 모듈화하기가 어려워집니다.
- [ ]  for문과 while문 중 하나를 선택해 사용하는 기준은 무엇일까요?
- 반복 횟수가 정해져 있을 때 for문을 사용합니다. for문은 초기화, 조건, 증감식이 한 줄에 들어가기 때문에 코드가 간결하고 가독성이 좋습니다. 반복 횟수가 정해져 있지 않으며 무한 반복문을 만들어야 할 때 while문을 사용합니다. while문은 조건식이 참인 동안 반복하기 때문에 반복 횟수가 정해져 있지 않을 경우에 사용하기 좋습니다.
- [ ]  for..in / for..of 에 대해서 설명해주세요.
(in / of 를 사용할 수 있는 대상은 무엇이 있는 지, 왜 그 대상들은 사용할 수 있는 지!)
- for...in은 객체의 속성을 순회할 때 사용됩니다. 객체의 속성은 문자열이기 때문에 for...in 반복문의 변수에는 속성 이름이 할당됩니다. for...of는 반복 가능한 객체의 요소를 순회할 때 사용됩니다. for...of 반복문의 변수에는 객체의 요소가 할당됩니다. for...in과 for...of는 각각 객체와 배열에서만 사용할 수 있는 것이 아니라, 다른 내장 객체에서도 사용할 수 있습니다. for...in은 객체의 속성 순서를 보장하지 않고, for...of는 배열의 요소 순서를 보장합니다.
- [x]  중첩 반복문에서 원하는 반복문을 제어(break/continue)하기 위한 방법은 무엇인가요?
- [ ]  원본 배열을 건들지 않고 splice 한 배열을 얻기 위해서는 어떻게 해야하나요?
- Array.slice() 메소드를 사용하면 원본 배열을 변경하지 않고 splice된 새로운 배열을 얻을 수 있습니다. slice() 메소드는 시작 인덱스와 끝 인덱스를 매개변수로 받아 새로운 배열을 반환합니다. 시작 인덱스는 포함되고, 끝 인덱스는 제외됩니다. 끝 인덱스를 생략하면, 시작 인덱스부터 배열의 끝까지를 반환합니다.
- [ ]  원본 배열을 건들지 않고 splice 되어진 배열을 얻기 위해서는 어떻게 해야하나요?
- Array.prototype.slice() 메소드를 사용하면 원본 배열을 변경하지 않고 배열의 일부르 추출할 수 있습니다. splice() 메소드와 달리 slice() 메소드는 인덱스를 기준으로 배열을 자르지만, 원본 배열의 요소를 삭제하거나 추가하지는 않습니다. slice() 메소드로 추출된 배열을 수정해도 원본 배열은 그대로 유지됩니다.
- [ ]  배열의 includes는 내부적으로 indexOf를 사용하여 결과가 -1인지 아닌 지를 반환할까요? 아니면 별도의 로직을 가지고 있을까요?
- 배열 메소드 includes()는 내부적으로 indexOf() 메소드를 사용하여 구현됩니다. includes()는 주어진 값이 배열에 존재하는지 여부를 불리언 값으로 반환합니다. 만약 값이 배열에 존재하지 않는다면 false를 반환하고, 존재한다면 true를 반환합니다. indexOf() 메소드는 주어진 요소가 배열에서 처음으로 나타나는 인덱스를 반환하고, 배열에 해당 요소가 없으면 -1을 반환합니다. includes() 메소드는 내부적으로 indexOf() 메소드를 사용하며, 반환 값에 따라 불리언 값을 반환합니다.
- [ ]  아래 코드에서 출력되는 값 a일까요 h일까요? 만약 h라면 target[0]이 바뀌지 않기 위해서는 어떻게 해야할까요?

```js
 const target = ['a', 'b', 'c', 'd', 'e'];
 const target2 = target;
 target2[0] = 'h';
 console.log(target[0]);

```

- 출력되는 값은 h입니다. target 배열의 첫 번째 요소를 변경하지 않고 target2 배열의 첫 번째 요소만 변경하려면 새로운 배열은 생성하여 할당해야 합니다.
- [ ]  함수를 정의하는 3가지 방법에 대해서 설명하고 차이점을 작성해주세요
- 함수 선언문은 코드의 어디에서든 호출이 가능합니다. 이는 함수가 호이스팅 되기 때문입니다. 함수 표현식은 변수에 할당되는 함수이므로, 할당된 변수를 통해서만 호출이 가능합니다. 화살표 함수는 함수 표현 식과 유사한 방식으로 함수를 정의하지만 함수 표현식보다 더 간결한 문법을 가지고 있습니다. 함수 선언문과 함수 표현식은 기본적으로는 같은 기능을 수행하지만, 호이스팅과 관련된 차이점이 있습니다. 함수 선언문은 호이스팅이 발생하므로, 함수를 선언하기도 전에 호출이 가능합니다. 하지만 함수 표현식은 호이스팅이 발생하지 않으므로, 변수에 할당된 이후에만 호출이 가능합니다.
- [ ]  함수의 파라미터의 수가 변할 수 있을 때, 어떤 식으로 파라미터를 받아야하나요?
- rest 파라미터는 ...을 사용하여 정의하며, 함수에 전달된 파라미터들을 배열로 받을 수 있습니다. 함수의 정의에서 마지막 파라미터로만 사용할 수 있습니다.
- [ ]  a,b,c 라는 id를 가진 div가 중첩되어 있고 자신의 id값을 출력하는 함수가 각 div의 이벤트 리스너로 설정되어있다면, 원하는 이벤트가 발생했을 때 어떤 순서로 출력 되나요?
- 가장 하위에 있는 a부터 c까지 abc 순서로 출력됩니다.