# JS

# 자료형과 연산자

- 세미콜론 사용 권장
- 주석
    - 한 줄 : //
    - 두줄 : /* */
- 코드의 가시성을 위해 들여쓰기 권장
- shitf + enter : console에서 줄바꿈
- multi line comment : /* */
- single line commet : //

## 문자열

1. 문자열 기호
- “” : 큰 따옴표 (줄바꿈 - \n사용)
- ‘’ : 작은 따옴표(줄바꿈 - \n사용)
- `` : 백틱 ( 줄바꿈 포함 가능)
1. 특수문자 표현
- “ : 작은따옴표나 백틱, 백슬래시 이용
- ‘ : 큰따옴표나 백틱, 백슬래시 이용
- \ : 백슬래시 두번 사용
1. 연산자
- (문자열)+(문자열) : 문자열이 합쳐짐
- (문자열)-(문자열) : NaN(Not a Number)
- (문자열)/(문자열) : NaN(Not a Number)
- (문자열)*(문자열) : NaN(Not a Number)
- (문자열)+숫자 = 숫자를 문자로!
- (문자열)-숫자 = 문자열을 숫자로!

## 숫자

1. 10의 제곱 형태로 표현 : 3e4 (30000), 3e-4(0.0003)
2. 숫자로 형변환
    - ParseInt() : 입력 받은 것에서 정수 추출
    - Number() : 소수점 그대로 표현
    - Typeof() : 자료형 표현
3. 숫자 연산자
    - + : 더하기
    - - : 빼기
    - * : 곱하기
    - / : 나누기
    - % : 나머지
    - ** : 제곱
    - +=: 어떤값에 추가적으로 더하기
    - -=: 어떤값에 추가적으로 빼기
    - *=: 어떤값에 추가적으로 곱하기
    - /=: 어떤값에 추가적으로 나누기
    - NaN : Not a Number
    - Infinity : 무한대
4. 연산자 우선순위
    - 연산자 우선순위 주의해서 식 작성
    - 괄호는 소괄호만 사용
5. 소수 계산 주의
- 소수를 바로 계산하면 부동소수점 문제로 정확한 값이 안나옴

      → 정수로 계산 후 10으로 다시 나누기

## Boolean

> : true와 false를 반환하는 자료형
> 
- true : 형 변환시 1에 가까움
- false : 형 변환시 0에 가까움

## 비교연산자

- a > = : 크거나 같다
- a < = : 작거나 같다
- == : 값이 같다( 자료형 X )
- === : 값과 자료형이 모두 같다.
- ! = : 값이 같지 않다 ( 자료형 X )
- ! = = : 값과 자료형이 같지 않다.
- NaN과의 비교연산은 ! = , ! ==가 아닌경우 모두 false
- 문자를 비교할때는 국어사전 순서 기준으로 비교
    
    (문자의 번호를 알고 싶을땐, charCodeAt() 사용)
    

## 논리 연산자

- && : and 연산자
- || : or 연산자
- ! : not 연산자
- !! : Boolean type을 알 수 있는 방법 , boolean() 또한 같은 역할
    - !! 사용시 무조건 false값이 나오는 경우
        - “(빈문자열)”
        - 0
        - NaN
        - undefined
        - null
        - document.all
- () : 논리 연산자의 우선순위 조정 가능

## undefined와 null

> undefined : 빈 값, 보통 반환할 결괏값이 없을때 나옴,  false와 같음
> 

<aside>
💡 console.log()시 undefined가 나오는 이유                   : console에 출력해주는 것 뿐이지, 반환하는 것이 아니기 때문

</aside>

> null : 빈 값, 임의적으로 빈 값을 지정해줄 때 사용, 자료형이 object ( not false ) → 버그이지만 수정되지 않음
> 

# 변수

## 변수

> : 변할 수 있는 특정 값을 저장하는 곳
> 

## 선언

> : 변수를 만드는 행위
> 

```jsx
let a;
```

## 초기화

> : 변수에 초기 값을 주는 행위
> 

```jsx
let a = 3;
```

## let

> : 변수를 선언할때 사용하는 것. 블록스코프에 저장
> 

## 변수 이름

1. 변수명은 겹치면 안된다.
    - 변수명이 겹칠 경우, 선언을 두번하게 되는 오류 발생. 각각 다른 값을 한 값에 저장하게 됨.
2. _와 $ 외에 특수기호는 사용할 수 없음
3. space(띄어쓰기 사용 불가)
    - 보통 띄어쓰기 대신 대문자를 사용
        
        ex ) StudentId
        
4. 숫자로 시작하면 안됨
5. 예약어는 변수로 사용할 수 없음
    
    <aside>
    💡 let은 왜 다른 에러가 나올까?                                                                                    es6이 나오기 전에 let이 유일하게 예약어가 아니었던 적이 있기 때문
    
    </aside>
    

## const

> : 거의 변하지 않는 상수 선언 및 초기화 시 사용, 블록스코프에 저장
> 

그러나 완전히 변하지 않진 않음. 나중에 배우는 객체 내부 값에는 적용되지 않음

## var

> : let과 비슷한 기능을 함, 함수스코프에 저장
> 
- 중복 선언 가능
- 예약어를 변수명으로 사용 가능
- 요즘 자주 사용하진 않음

# 조건문

> 조건문 : 조건식에 따라 동작문이 동작하고 동작하지 않는 문
> 
1. if 문
    
    > : if 괄호문의 조건식에 따라 동작문이 동작
    > 
    
    ```jsx
    if(false){
    	console.log("hello, if!");
    ```
    
2. if - else 문
    
    > : if 괄호문의 조건식에 따라 동작문이 동작, 조건식 성립하지 않을시 else 동작문 동작
    > 
    
    ```jsx
    if(false){
    	console.log("hello, if!");
    }else{
    	console.log("hello, else!");
    }
    ```
    
3. else if문
    
    > : if 괄호문의 여러가지 조건식에 따라 순차적으로 내려가며 동작문이 동작,  조건식 성립하지 않을시 else 동작문 동작
    > 
    
    ```jsx
    let num=3;
    if(num<0){
    	console.log("-");
    else if(num>0){
    	console.log("+");
    else{
    	console.log("0");
    }
    ```
    
4. switch 문
    
    > : switch 괄호 안에 값이 case 옆의 값과 같으면 출력 , braek 없으면 밑 case까지 출력
    > 
    
    ```jsx
    let value=”A”;
    switch(value){
    	case 'A' :
    		console.log('A');
    		break;
    	case 'B' : 
    		console.log('B');
    		break;
    }
    ```
    
5. 조건부 연산자
    
    > 조건식 ? 참일때 실행되는 식 : 거짓일때 실행되는 식
    > 
    - 조건부 연산자는 문이 아니라 식이기 때문에 결과값이 나온다.
    
    ```jsx
    let value= 5<0 ? “참” : “거짓”;
    ```
    
    - 식이 복잡해질 때, 가독성을 위해 짝을 잘 맞추어 괄호 써주기
    
    ```jsx
    let condition1 = true;
    let condition2 = false;
    let value = condition1 ? (condition2 ? : “둘다 참” : “ condition1만 참”) : “condition1이 거짓”;
    console.log(value);
    ```
    

# 반복문

## 1. while문

```jsx
while(조건문){ 동작문;}
```

## 2. for문

```jsx
for(시작; 조건식; 종료식){ 동작문; }
```

## 3. 중첩된 반복문

> : 반복문이 이중으로 중첩되어 사용되는 경우
> 

```jsx
for(let i=0; i<10; i++){
	for(let j=0; j<10; j++){
		console.log(i,j);
		}
} 
```

## break

> : 반복문을 빠져나오는 명령
> 

```jsx
let i=0;
while(true){
	if(i===5) break;
	i++;
}
```

## continue

: 동작문을 한번 건너뛰고, 다음 단계로 가는 명령

```jsx
let i=0;
while(i<10){
	i++;
	if(i%2===0){
		continue;
	}
}
```

# 배열

## 객체

> : 자료형의 일종으로 다양한 값을 모아둔 값
> 

## 배열

```jsx
const fruits = [’사과’, ‘오렌지’, ‘배’, ‘딸기’];
const arrayOfArray=[[1,2,3],[4,5]];
```

const인데 수정 가능한 이유 : const는 객체가 대입된경우 내부 속성이나 배열의 요소는 수정 가능

### 배열 요소 접근 : array[i] 형식으로 접근 가능

### 마지막 요소 접근

배열은 0번부터 시작하기 때문에 배열의 마지막 요소 접근은 array[array.length-1]을 통해 할 수 있다.

### .length : 배열 요소의 개수 구하기

‘ ‘, NaN 또한 count 대상

### unshift : 배열 가장 앞에 요소 추가

### pop: 배열 가장 마지막 요소 제거

### push : 배열 가장 마지막 요소 추가

### splice : 배열 중간요소 제거

```jsx
splice(1,3) // 1번째 요소에서 3개제거
```

### includes : 배열 요소 존재 여부 찾기

### indexof : 배열 요소 위치 찾기

### lastindexof : 뒤에서부터 배열 요소 위치 찾기

```jsx
const arr=[1,2,3,4,5];
if(arr.indexOf(1)){
//if(arr.indexOf(1)>-1)로 수정시 제대로 동작
	console.log("1 찾았다");
}else{
	console.log("1 찾았다"):
}
// 1 못찾았다로 나옴. 
```

# 함수

## 함수

> : 일정한 동작을 수행하는 코드
> 

```jsx
//함수 사용 형식
function a (){} // 함수 선언문
const b = function(){}; // 함수 표현식
const c = () => {}; // 화살표 함수
a(); // 함수 호출
function(){} // 익명함수, 한번만 사용 가능 
```

## return

> : 함수 호출시 반환 하며 종료하는 값
> 

### return undefined 생략

```jsx
console.log(’a’) // return undefined (반환값이 없는 것이 아님)
```

### function return 형식

```jsx
function b(){
	return '반환값';
}
b(); // return '반환값'
```

### 여러값 동시 return

```jsx
function a(){
	return [1,5];
} // 배열을 return
```

### 매개변수, parameter

> : 함수 선언시 괄호 안에 있는 값.
> 

### 인수 , argument

> : 함수 호출시 괄호 안에 있는 값.
> 

```jsx
function a(x,y,z,t){
	console.log(x,y,z,t);
	console.log(arguments); 
	// 배열 모양으로 출력해줌, 화살표 함수에서는 불가능
}
a('hello','parameter','argument');
// 출력 : ['hello','parameter','argument','undefined']
// 매개변수 기본 값 undefined, 매개변수가 인수보다 많을 경우 마지막 인수 무시
```

### 화살표 함수 활용

```jsx
const f =(x,y,z) ⇒ x*y*z;
```

# 객체 리터럴

## 객체

> : 여러 개의 변수를 하나의 변수로 묶을때 사용
> 

객체와 배열의 차이는 객체 속성값의 이름 부여 차이

const이지만 객체 내부는 수정 가능

```jsx
const me={ name: '이서현', year: 2002,  month: 6,  date: 15,};
console.log(me.name); // 속성 값 접근
console.log(me['name']); // 속성 이름이 특수한 경우 사용 (띄어쓰기, 특수문자 포함)
console.log(me[name]); // me['이서현']과 같아짐, 대괄호 사용시 따옴표 주의
```

## 객체 속성 수정하기

```jsx
[me.name](http://me.name) = ‘서현이’;
```

## 객체 속성 삭제하기

```jsx
delete me.name;
```

## 함수와 배열이 객체인 이유

- 배열과 함수가 객체의 성질(속성 수정, 제거 등)을 모두 사용 가능하기 때문
- 다만, 함수와 배열, 객체 리터럴은 사용 목적이 다르기 때문에, 임의 속성을 넣을 거라면, 객체 리터럴 사용 권장

## 메서드

> : 객체 안에 있는 함수
> 

```jsx
const debug={
	log : function(value){
		console.log(value);
},
};
debug.log('hello seony');

```

## 객체 간의 비교

- 객체끼리 비교시 항상 false 나옴, 따라서 객체 비교시에는 꼭 변수 안에 저장하고 비교 해야 함.
- 메모리의 위치가 다른 것이기 때문에 이름과 속성이 같아도 다르다고 인식
- 객체가 아닌 값들은 속성값을 서로 비교하는 곳이 존재하기 때문에 같다고 인식

```jsx
const a ={name : 'seony'} //객체 리터럴
const array = [1,2,a]; // 배열 리터럴 
console.log(a === array[2]);
```

- 참조의 경우 같음. 같은 주소의 객체를 가지고 있는 것이기 때문, 원시값의 경우 참조가 아니기 때문에 같지 않음

```jsx
const a= {name :’seony’}
const b= a; // 참조
a.name ='hero';
console.log(b.name); // hero
```

# DOM 객체 다루기_ 끝말잇기 게임

## 순서도그리기

> :  코드를 작성하기 전에 구체적으로 순서를 정하기 위해서 작성
> 

### 1. 번호 스타일

> : 숫자를 통해 순서를 나타내는 순서도 그리기 방식
> 

### 2. 그림 테스트

> : 순서도를 그림으로 나타내는 순서도 그리기 방식
> 

## 프로그램 절차 설계 시 원칙

- 프로그램 절차의 개수는 정해져 있어야 한다.
- 각 절차는 항상 같은 내용이어야 한다.
- 모든 가능성을 고려해야 한다.
- 예시는 절차를 검증하는 데 사용한다.

## 끝말잇기 게임 번호 스타일 순서도 예시

1. 게임에 몇 명이 참가할 지 선택한다.
2. 참가자 순서를 숫자를 통해 정한다.
3. 첫 번째 사람이 어떤 단어를 말한다.
4. 다음 사람이 어떤 단어를 말한다.
5. 절차 4에서 말한 단어가 올바른지 판단한다. 
6. 올바르다면 그 다음 사람이 어떤 단어를 말한다.
7. 올바르지 않다면 틀렸다고 표시한다.
8. 게임을 계속 진행(절차 4로 이동)한다. 

## 끝말잇기 게임 그림 테스트 순서도 예시

- 시작과 끝은 두개의 겹쳐진 원
- 화살표로 순서나 방향 표시
- 마름모를 통해 분기점 표현
- 네모는 이벤트나 대기 표시

## 단축키

- shift + alt+ 방향키 ⇒ 복사
- shift + tap ⇒ 들여쓰기
- f5 + chrom ⇒ 웹으로 html 열기

### prompt

> : 대화 상자를 통해 값을 문자로 입력 받는다.
> 

### confirm

> : 확인을 누르면 true가 , 취소를 누르면 false가 입력되는 사용자의 확인을 요구한다.
> 

### alert

> : 사용자에게 경고 메시지를 표시한다.
> 

# 선택자

## document.querySelector

> : HTML 태그를 선택하여 값을 반환한다. ( 가장 첫번째 하나만)
> 

## document.querySelectorAll

> : document.querySelector와 달리 태그를 갖고있는 모든 요소에 적용
> 

## Nodelist[]

> : 0을 속성 이름으로 가지고 있는 배열, 배열은 아닌데 겉보기엔 배열처럼 보이는 객체, 유사배열
> 

ex) arguments

## document.querySelector(’#id’)

> :document.querySelector나 document.querySelectorAll에서 id를 넣어주는 경우 id는 고유한 값이기 때문에 태그 생략하고 id만 주로 사용
> 

## document.querySelector(’.class’)

> :document.querySelector나 document.querySelectorAll에서 class를 넣어주는 경우 사용, 태그 포함해서 사용하기도 함.
> 

## document.querySelector(’선택자1 선택자2’)

> :document.querySelector나 document.querySelectorAll에서 선택자1의 자손인 선택자2인 경우만 해당할 때 사용
> 

## document.querySelector(’선택자1 > 선택자2’)

> :document.querySelector나 document.querySelectorAll에서 선택자1의 바로 자식인 선택자2인 경우만 해당할 때 사용
> 

# 이벤트 리스너

## 이벤트 리스너

> : 어떠한 이벤트가 일어났을때 콜백 함수 호출
> 

<aside>
💡 태그.addEventListner(’이벤트 이름’, 리스너 함수);

</aside>

```jsx
document.querySelector(’input’).addEventListener(’input’, (event) ⇒ {
	console.log('글자 입력', event.target.value);
}
// 입력할때마다 console로 입력값 알려줌
```

### word를 id로 가지고 있는 태그에 textcontent를 변경[제시어 변경]

```jsx
const $word = document.querySelector(’#word’);
$word.textContent = word;
//textContent는 반드시 문자열
```

### 태그의 내부값 속성

- input - value
- button - textContent
- select - value
- div - textContent
- textarea -value
- span - textContent

### focus

> : 해당 태그에 커서가 반짝반짝 거린다.
> 

<aside>
💡 입력창.focus()

</aside>

# 순서도 최적화

## OR의 관계

> : 첫번째 조건, 두번째 조건 모두 False 여야 False
> 

## And의 관계

> : 첫번째 조건, 두번째 조건 모두 True여야 True
>