# Javascript_1

끝에 세미콜론 붙이기

필기에 사용한 창작기호 

...< : 컴퓨터가 되돌려준 값  

...> : 사용자가 추가로 입력한 값

주석 : // 이 뒤에 작성 or /* 이 사이에 작성 */

들여쓰기 : 보기좋게 만들기 위해 두 칸 or 네 칸 or 탭. 

들여쓰지 않아도 실행에는 문제가 없다.

값(value) : 프로그램이 조작할 수 있는 데이터.

값의 종류 : 문자열, 숫자, 불(bool/참과 거짓) 

문자열 : "큰 따옴표" 또는 '작은 따옴표, `백틱`를 사용하여 생성.

백틱만 엔터를 줄바꿈으로 인식한다.

이외에는 \n(역슬래시 n)을 사용한다.

문자열에 따옴표를 넣고 싶다면, 따옴표 앞에 \(역슬래시)를 사용하면 된다.

역슬래시를 넣고 싶다면, 역슬래시를 두 번 반복해서 적으면 된다.

typeof 를 사용하여 값의 종류를 알 수 있다. 

ex. typeof '문자열'                                      

문자열과 문자열 사이에 +를 넣으면 서로 합쳐진다.

ex. '바나나' + '사과'

'바나나' - '사과' 와 같은 경우, NaN(Not a Number)가 출력된다.(NaN은 숫자이다.)

+ - * / % **등은 파이썬과 동일하다.

0b : 2진법 / 0 : 8진법 / 0x : 16진법

숫자로만 이루어진 문자열에 숫자를 더하면 숫자와 숫자가 이어진 문자열이 된다.

ex. '124' + 5 ...< "1245". 

글자가 들어간 문자열에 숫자를 더하면 글자와 숫자가 이어진 문자열이 된다. 

ex. '문자열' + 0 ...< '문자열0'

빼기 곱하기 나누기는 값이 숫자가 아닌 문자열이 숫자로 바뀐다.

이렇게 값이 변하는 것을 형 변환이라고 한다.

Number() : 내부에 들어간 숫자를 숫자 자료형으로 바꿀 수 있다.

parseInt() : 내부에 들어간 문자열을 정수로 바꿀 수 있다.

ex. Number('123.5') ...< 123

parseFloat() : 내부에 들어간 문자열을 소수점을 포함한 실수로 바꿀 수 있다.

차이점 : parseInt와 parseFloat의 경우 내부에 글자가 들어가 있을 때에, 숫자만 빼낼 수 있으나 Number의 경우 NaN을 내보낸다.

자바스크립트는 파이썬과 달리 정수와 소수점을 포함한 실수 모두 숫자형 하나이기 때문에 구분이 필요없다.

prompt() : 파이썬의 input과 비슷하다.

Infinity, -Infinity : 양의 무한대, 음의 무한대

부동소수점 문제

이진법으로 인해 0.1 + 0.2 가 0.3000... 으로 표시된다.

-> 이를 해결하기 위해, 실수를 정수로 바꿔 계산한 뒤 마지막에 다시 실수로 바꾸는 방법이 있다.

ex. ( 0.3*10 - 0.1*10 ) / 10 ...< 0.2

불(bool) 값 :true, false로 나뉜다.

>= : 크거나 같다(파이썬과 동일하다)... 이외 <= == != 등도 파이썬과 동일하다.  

=는 파이썬과 동일하나,

== : 값만 비교하고 자료형이 같은지는 비교하지 않는다.

=== : 값 뿐만 아니라 자료형과 같은지도 함꼐 비교한다.

.charCodeAt()을 통해 문자열의 값을 비교할 수 있다.

ex. 'a'.charCodeAt() ...< 97

&& : 그리고(and)

ex. 10 > 5 && 6 < 8 ...< true

|| : 또는(or)

! : 부정(Not)

!! : 값 앞에 느낌표 두 개를 붙이면 불로 형변환이 된다

ex. !!0 ...

++의 사용법. 아래 세가지의 식은 결과가 모두 동일하다.

i = i + 1 ...... i += 1 ...... i++

- - 도 비슷한 형태로 사용이 가능하다

형 변환 시 false가 되는 것들 : false, ' '(빈 문자열), 0, NaN, undefined, null

undefined : 돌려줄 것이 없다. 정확히는, undefined를 돌려준다.

자료형의 일종. typeof undefined ...< "undefined" 

bool값으로 바꾸면 false

null : 보통 도적으로 사용한다.

typeof null ...< "object" (자바스크립트의 오류. null이 맞음) 

undefined == null ...< true

undefined === null ... <true

**변수 선언하기(let)**

변수 : 특정 값을 저장하기 위해

let string = 2341243215; ...> string ...< 2341243215

console.log() : 단순히 화면에 값을 표시하는 것.

let total = 5000 + 8000 + 10000 + 9000; …<undefined 

이렇게 선언과 동시에 값을 넣는 것을 초기화했다고도 한다.

변수를 선언할때 컴퓨터는 언제나 undefined 값을 돌려준다.

변수명의 맨 앞글자가 숫자일 수는 없다.

**변수 값을 수정할 때**

let asdf = 12 …> asdf = 15 …> asdf …< 15 값을 비울 땐 undefined나 null을 쓴다

const

: 어떤때(ex. 객체의 내부를 변경할 때)는 값을 바꿀 수 있지만, 대체로 값을 바꿀 수 없음(재대입이 되지 않는다.) 

const asdf = 15 …> asdf =30 …< TypeError

var(variable)과거에 쓰이던 변수. let과 기본적으로 똑같으나, 다시 선언해도 에러가 나지 않는다.

**if문**

조건문 기본 형태 

if (조건식) 

    동작문;

두 가지 이상의 동작문을 작성할 때 

if (조건식) { 

    동작문 1; 

    동작문 2, 

    동작문 3, }

if (조건식) { 

    동작문 1; 

} else { 

    동작문 2; 

} else if (조건식) { 

    동작문 3;

```jsx
const score = 75

; if (score >= 80) { 

    console.log(‘A+’); 

} else if (score >= 70) {

    console.log(‘A’); 

} else { 

    console.log(‘B’); 

}          …< A 

// 순서대로 진행하고, 조건이 맞으면 if문 내에서 나가기 때문에 상위조건을 다시 정하지 않아도 괜찮다.
```

**switch 문**

switch (조건식) { 

    default: 

        동작문; 

    case 비교조건식: 

        동작문; } 

// 조건식과 비교조건식이 동일하면 실행된다.

else if처럼, case를 여러가지 넣어 작동시키는 것도 가능하다. 단, 조건이 맞으면 if문에서 빠져나가는 여타 if문과는 달리, switch의 case는 빠져나가지 않고, 자신이 위치한 switch문 내에서 조건을 만족하는 비교조건식 아래로 적힌 동작문들을 모두 실행한다. 동작문 끝에 break을 적어, 이후의 타 동작문을 실행하는 것을 막을 수 있다.

if문에서는 else가 가장 마지막에 위치해야 하지만, switch문에서는 defalut를 중간 혹은 맨 앞에 넣어도 문제가 없다.

```jsx
let value = 'A'
switch (value) {
    default:
        console.log('X')
    case 'A' :
        console.log('A') ;
    case 'B' :
        console.log('B');
}
```

**조건부 연산자** 

기본 형태 - 조건식 ? 참일 때 실행되는 식 : 거짓일 때 실행되는 식 

if문과 달리, 문이 아니라 식이기 때문에, 결과값이 나온다. 

```jsx
5 > 0 ? “참입니다” : “거짓입니다”
```

변수에 대입할 수 있다. 

```jsx
let value = 5 < 0 ? “참입니다” : “거짓입니다”
```

중첩해서 사용할 수 있다.(괄호나 들여쓰기를 사용하여 편히 구분할 수도 있 다.) 

let value = condition1 ? (condition2 ? ‘둘 다 참’ : ‘condition 1만 참’) : ‘condition 1이 거짓’ ; 

let value = condition1 ? ‘condition1이 참’ : condition2 ? ‘condition2가 참’ : ‘둘 다 거짓’ ;

**반복문** : while, for

while (조건식) 

    동작문;

let i = 0; 

while (i < 100) { 

    console.log(i + 1); 

    i++; 

}

for (시작; 조건식; 종료식) 

    동작문;

실행 순서 : 시작 조건식 동작문 종료식 조건식 동작문 종료식 조건식 동작문 종료식……

for문은 식 안에서 변수를 선언할 수 있다. for (let i = 0; i < 100; i++) console.log(“Hello, for!”)

break : 파이썬과 용도가 동일하다

```jsx
let i = 0;
while (true) {
    if( i === 5 ) break;
    i++;
}
```

continue : 다음줄을 실행하지 않고, 바로 다음 반복문으로 넘어간다. 

```jsx
let i = 0 
while (i < 10) {
    i++;
    if ( i % 2 === 0) { //짝수만
    continue;
```

중첩된 반복문

```jsx
for (let i = 0; i < 10; i++) {
    for ( let j = 0; j < 10; j++) {
        console.log(i, j);
    }
}                                     ....< 0, 0 ...< 0, 1 ...< 0, 2 ......< 0,9 ...< 1, 0 ...<  1, 1 ...< 1, 2 ......

for (let i = 0; i < 5; i++) {
    console.log('*'.repeat(i + 1))
}
```

```jsx
// 거꾸로 만들기 실습
for (let i = 5; i > 0; i -= 1) {
    console.log('*'.repeat(i))
}

// 실습 2
for (let i = 0; i < 5; i++) {
    console.log('*'.repeat(5 - i))
}
```

**객체**(object)

: 자료형의 일종으로, 다양한 값을 모아둔 또다른 값. 종류는 크게 배열(array)과 함수(function), 배열이나 함수가 아닌 객체로 나눌 수 있다.

**배열** 또는 배열 리터럴 

예시와 같이 값들을 하나로 묶을 수 있다.

```jsx
const fruits = ['사과', '오렌지', '배', '딸기'];
```

요소의 개수를 셀 때 : .length 

```jsx
const everything= ['사과', '1', undefined, true, '배열', null];
console.log(everything.length);
```

특정 값을 불러오는 예시

```jsx
console.log(fruits[0]);
```

배열 안에 배열을 넣을 수 있다. 

```jsx
const arrayOfArray = [[1, 2, 3], [4,  5]];
arrayOfArray[0]; ...< [1, 2, 3]
const a = 10;
const b = 20;
const variableArray = [a, b, 30]
variableArray[1]; //b의 값
```

마지막 요소의 값을 불러오는 법 

```jsx
const findLastElement = ['a', 'b', 'c', 'd', 'e'];
console.log(findLastElement[findLastElement.length - 1]);
```

다음 배열에 요소를 추가하기 

```jsx
const target = ['가', '나', '다', '라',];
target[target.length] = '마';
```

배열을 수정하기 

```jsx
const target = ['아', '나', '다', '라', '마'];
target[0] = '가';
```

배열의 맨 앞에 요소를 추가하기 : unshift 

```jsx
const target = ['나', '다', '라', '마'];
target.unshift('가')
```

마지막 요소를 제거하기 : pop 

```jsx
const target = ['가', '나', '다', '라', '마', '바'];
target.pop();
```

첫번째 요소를 제거하기 : shift 

```jsx
const target = ['아', '가', '나', '다', '라', '마'];
target.shift();
```

중간 요소를 제거하기 : splice(인덱스, 갯수)

```jsx
const target = ['가', '나', '아' '다', '라', '마'];
target.splice(2, 1);
```

지우는 것 뿐만 아니라, 지워진 자리에 다른 값을 넣을 수도 있다. 

```jsx
const target = ['가', '타', ''다', '파', '마'];
target.splice(1, 3, '나', '다',  ''라');
```

지우지 않고, 다른 값을 넣을 수도 있다. 

```jsx
const target = ['가', '나', '라', '마'];
target.splice(2, 0, '다');
```

특정 요소가 있는지 찾기 : includes 

```jsx
const target = ['가', '나', '다', '라', '마'];
const result = target.includes('다');
const result2 = target.includes('카');
console.log(result);
console.log(result2);
```

특정 요소가 몇 번째 인덱스에 위치하는지 찾기 : indexOf, lastIndexOf 

```jsx
const target = ['가', '나', '다', '라', '마'];
const result = target.indexOf('다');
const result2 = target.lastIndexOf('라');
```

indexOf는 앞에서부터, lastIndexOf는 뒤에서부터 찾는다.

배열 반복하기 : while문과 for문 모두 가능하다. 문자열에서도 응용 가능하다. 

```jsx
const target = ['가', '나', '다', '라', '마'];
let i = 0;
while (i < target.length) {
    console.log(target[i]);
    i++;
}

const target = ['가', '나', '다', '라', '마'];
for (let i = 0; i < target.length; i++) {
    console.log(target[i]);
}
```

실습 라 제거하기 

```jsx
while (arr.indexOf('라') > -1) {
    arr.splice(arr.indexOf('라'), 1)
}

let index = arr.indexOf('라');
while (index > -1) {
    arr.splice(index, 1);
    index = arr.indexOf('라')
}
```

**함수**

: function() {} 또는 () => {}와 같이 만든다. 이름을 붙여주어야 하기에, 아래와 같은 방법들을 쓴다. 이름을 붙여주지 않은 함수는 익명함수라고 칭하며, 1회성으로 사용된다. 

```jsx
function a() {}
const b = function() {};
const c = () => {};
```

예시 a와 같이, if for while 함수선언문 뒤에는 ;를 안붙이고는 한다.

return의 사용법은 파이썬과 동일하다.(종료하며 반환한다.) 여러값을 동시에 리턴하고 싶다면, 배열을 사용해야 한다. 리턴 값은 하나만 가능하기 때문.

```jsx
function a() {
    return [1, 5];
}
```

선언 : 매개변수(parameter) 

호출 : 인수(argument)

함수 호출 parameter = ‘argument’

```jsx
fuction add(x, y) {
    return x+y;
}         ....> add(5, 3)   ...< 8

//ex. 
multiply = (x, y, z) => {   //매개변수 x, y, z
    return x * y * z
}
multiply(2, 3, 4) ...< 24 ///인수 2, 3, 4
```

중괄호+return이 바로 나오면, 둘을 생략할 수 있다. 

```jsx
const f = (a, b) => {return a + b)}
const f = (a, b) => a  + b;
```

매개변수와 인수의 갯수가 서로 다르면, 다른 만큼은 무시된다.

**객체 리터럴** 

```jsx
const hong = {
    name: '홍길동' ,
    birth: 900101,
    gender: 'M'
};
```

name, birth, gender은 속성명, ‘홍길동’, 900101, ’M’은 속성값이다. 

마지막 속성에는 쉼표를 찍어도, 찍지 않아도 작동한다. 

속성명 맨앞에 숫자를 넣거나, 특수기호 또는 띄어쓰기를 포함할 경우 따옴표로 감싸야한다.

다음과 같은 방법으로 속성값을 불러올 수 있다. 

```jsx
console.log(hong.name);
console.log(hong['name']);
```

앞에서 설명한, 따옴표로 감싸야만 작동하는 속성명은 두번째 방법으로만 접근할 수 있다.

객체 속성 추가 또는 수정하기

```jsx
hong.hello = 'hi'
hong.birth = 200101
```

객체 속성 제거하기

```jsx
delete hong.gender
```

**메서드**(method)

: 객체의 속성값으로 함수를 넣었을 때, 이 속성을 칭하는 말

```jsx
const debug = {
    log: functhoin(value) {
        console.log(value);
    },
};
debug.log('Hello, Method');
```

객체가 아닌 값들은 같은 값들은 서로 비교했을때 true가 나오지만, 배열과 함수 등 객체들은 무조건 false가 나오기 때문에, 변수 안에 저장하고 비교를 해야 한다.

```jsx
const a = { name : '홍길동'};
const array = [1, 2, a];
console.log( a === array[2]);
```

내부의 값이 같아도, 새로 만들어진 객체로 취급이 되기 때문에 false가 된다.

객체가 아닌 값들은 원시값이라고 한다.

다음과 같이, 객체 안에 객체가 있을 수도 있다.

```jsx
const hong = {
    name: {
        first: '길동',
        last: '조',
    },
    gender: 'M',
};
```

**참조**(reference) 

```jsx
const a = { name: '홍길동' };
const b = a
a.name = '김철수' ;
console.log(b.name); ...< '김철수'
```

html코드 본문(body 태그) 내에 **<script></script>** 를 삽입하고 사이에 자바스크립트 코드를 입력한다

parseInt() : 값을 숫자로 바꾼다. 

prompt() : 사용자로부터 값을 입력받는다. 

alert() : 알림창을 띄운다. 

confirm() : True or False를 받는다.

**HTML 태그 선택하기**

: document.querySelector(‘선택자’) 의 양식으로 선택할 수 있다. 다만, 동일한 태그 중 첫 번째 하나만 선택한다.

```jsx
const Alpha = document.querySelector('button')
```

동일한 태그가 여러 개 일 때, 해당되는 태그를 모두 선택하려면 document.querySelectorAll 함수를 이용한다.

```jsx
document.querySelectorAll('input')
//NodeList[input]를 되돌려준다.
```

NodeList가 뜨면, 객체라는 뜻이다.

```jsx
document.querySelector('.btn') 
// 클래스가 btn인 태그를 선택한다.

document.querySelector('button.btn') 
// button인 동시에, 클래스가 btn인 태그를 선택한다.
```

태그 사이에 공백이 있으면 자손 태그를 선택한다. 

```jsx
ex. const Aspan = document.querySelector('div span') 
// div의 자손 중 span 태그를 선택한다.

document.querySelector('body #target button') 
// body 태그 안에 들어있는 id가 target인 태그에서 다시 그 안에 들어있는 button 태그를 찾는다.
```

자손 태그와 자식 태그의 차이점. 자손 태그는 그 내부의 모든 태그를 칭하지만, 자식태그는 바로 자식인 태그 중에서만 선택된다.

**이벤트 리스너 달기**(콜백함수) : 태그.addEventListender(‘이벤트 이름’, 리스너함수); 

```jsx
document.querySelector('input').addEventListener('input', function() {
    console.log('글자 입력');
});
```

다음과 같이 함수를 바깥으로 빼는 것도 가능하다. 

```jsx
const onClock = fuction() {
    console.log('버튼 클릭');
}
document.querySelector('button').addEventListener('click', onClick);
//마지막줄의 onClick은 함수자리이기 때문에, onClick 뒤에 ()를 붙이지 않고 함수 이름만 적는다.
```

아래와 같이 화살표 함수를 사용하거나, event를 넣을 수 있다. 

```jsx
document.querySelector('input').addEventListener('input', (event) => {
    console.log('글자 입력', event.target.value);
});
```

대부분의 text 컨텐츠를 바꾸는 방법 : .textContent 

해당 컨텐츠 : button, div, span 

```jsx
Aword.textContent  =  word ;
```

input등의 몇가지 컨텐츠를 바꾼다 : .value 

해당 컨텐츠 : input, select, textarea

```jsx
Ainput.value  = ' ';
```

컨텐츠에 커서를 둔다 : .focus

```jsx
//실습 끝말잇기

<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>끝말잇기</title>
</head>

<body>
    <div><span id="order">1</span>번째 참가자</div>
    <div>제시어: <span id="word"></span></div>
    <input type="text">
    <button>입력</button>
    <script>
        const number = Number(prompt('몇 명이 참가하나요?'), 10);
        const AButton = document.querySelector('button');
        const Ainput = document.querySelector('input');
        const Aword = document.querySelector('#word')
        const Aorder = document.querySelector('#order')
        let word; //제시어
        let newWord; //새로 입력한 단어

        const onClickButton = () => {
            if (!word ||word[word.length - 1] === newWord[0]) {
                word = newWord; //입력한 단어가 제시어가 된다.
                Aword.textContent = word;
                const order = Number(Aorder.textContent); //현재 순서
                if (order + 1 > number) {
                    Aorder.textContent = 1;
                } else {
                    Aorder.textContent = order + 1
                }
            } else {//올바르지 않은가
                    alert('올바르지 않은 단어입니다.')
                    Ainput.value = '';
            }
            Ainput.value = '';
            Ainput.focus();
        };
        const onInput = (event) => {
            newWord = event.target.value;
        }
        AButton.addEventListener('click', onClickButton)
        Ainput.addEventListener('input', onInput)
    </script>
</body>

</html>
```

```jsx
//실습 쿵쿵따

<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>쿵쿵따</title>
</head>

<body>
    <div><span id="order">1</span>번째 참가자</div>
    <div>이전단어: <span id="word"></span></div>
    <input type="text">
    <button>입력</button>
    <script>
        const number = Number(prompt('몇 명이 참가하나요?'), 10);

        if(!number){
        const AButton = document.querySelector('button');
        const Ainput = document.querySelector('input');
        const Aword = document.querySelector('#word')
        const Aorder = document.querySelector('#order')
        let word; //이전 단어
        let newWord; //새로 입력한 단어

        const onClickButton = () => {
            if (!word || (word[word.length - 1] === newWord[0] && newWord.length == 3)) { //제시어가 비어있는가?
                //비어있다.
                word = newWord; //입력한 단어가 이전 단어로 간다.
                Aword.textContent = word;
                const order = Number(Aorder.textContent); //현재 순서
                if (order + 1 > number) {
                    Aorder.textContent = 1;
                } else {
                    Aorder.textContent = order + 1
                }
            } else {//올바르지 않은가
                    alert('올바르지 않은 단어입니다.')
                    Ainput.value = '';
            }
            Ainput.value = '';
            Ainput.focus();
        };
        const onInput = (event) => {
            newWord = event.target.value;
        }
        AButton.addEventListener('click', onClickButton)
        Ainput.addEventListener('input', onInput)
    }
    </script>
</body>

</html>
```